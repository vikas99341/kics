
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>console: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Checkmarx/kics/internal/console/generate_id.go (80.0%)</option>
				
				<option value="file1">github.com/Checkmarx/kics/internal/console/helpers/helpers.go (82.7%)</option>
				
				<option value="file2">github.com/Checkmarx/kics/internal/console/kics.go (87.0%)</option>
				
				<option value="file3">github.com/Checkmarx/kics/internal/console/list_platforms.go (100.0%)</option>
				
				<option value="file4">github.com/Checkmarx/kics/internal/console/printer/printer.go (58.7%)</option>
				
				<option value="file5">github.com/Checkmarx/kics/internal/console/scan.go (81.7%)</option>
				
				<option value="file6">github.com/Checkmarx/kics/internal/console/version.go (100.0%)</option>
				
				<option value="file7">github.com/Checkmarx/kics/internal/storage/memory.go (100.0%)</option>
				
				<option value="file8">github.com/Checkmarx/kics/internal/tracker/ci.go (100.0%)</option>
				
				<option value="file9">github.com/Checkmarx/kics/pkg/builder/engine/engine.go (71.8%)</option>
				
				<option value="file10">github.com/Checkmarx/kics/pkg/builder/model/model.go (100.0%)</option>
				
				<option value="file11">github.com/Checkmarx/kics/pkg/builder/parser/tag/tag_parser.go (92.0%)</option>
				
				<option value="file12">github.com/Checkmarx/kics/pkg/builder/writer/rego.go (89.8%)</option>
				
				<option value="file13">github.com/Checkmarx/kics/pkg/detector/default_detect.go (100.0%)</option>
				
				<option value="file14">github.com/Checkmarx/kics/pkg/detector/detector.go (100.0%)</option>
				
				<option value="file15">github.com/Checkmarx/kics/pkg/detector/docker/docker_detect.go (90.3%)</option>
				
				<option value="file16">github.com/Checkmarx/kics/pkg/detector/helm/helm_detect.go (88.1%)</option>
				
				<option value="file17">github.com/Checkmarx/kics/pkg/detector/helper.go (96.2%)</option>
				
				<option value="file18">github.com/Checkmarx/kics/pkg/engine/inspector.go (74.1%)</option>
				
				<option value="file19">github.com/Checkmarx/kics/pkg/engine/provider/filesystem.go (76.2%)</option>
				
				<option value="file20">github.com/Checkmarx/kics/pkg/engine/similarity_id.go (92.3%)</option>
				
				<option value="file21">github.com/Checkmarx/kics/pkg/engine/source/filesystem.go (77.9%)</option>
				
				<option value="file22">github.com/Checkmarx/kics/pkg/engine/vulnerability_builder.go (80.0%)</option>
				
				<option value="file23">github.com/Checkmarx/kics/pkg/kics/resolver_sink.go (73.9%)</option>
				
				<option value="file24">github.com/Checkmarx/kics/pkg/kics/service.go (86.7%)</option>
				
				<option value="file25">github.com/Checkmarx/kics/pkg/kics/sink.go (68.4%)</option>
				
				<option value="file26">github.com/Checkmarx/kics/pkg/model/model.go (100.0%)</option>
				
				<option value="file27">github.com/Checkmarx/kics/pkg/model/model_easyjson.go (0.0%)</option>
				
				<option value="file28">github.com/Checkmarx/kics/pkg/model/sarif.go (95.7%)</option>
				
				<option value="file29">github.com/Checkmarx/kics/pkg/model/summary.go (87.0%)</option>
				
				<option value="file30">github.com/Checkmarx/kics/pkg/parser/docker/parser.go (90.6%)</option>
				
				<option value="file31">github.com/Checkmarx/kics/pkg/parser/json/parser.go (72.7%)</option>
				
				<option value="file32">github.com/Checkmarx/kics/pkg/parser/parser.go (94.5%)</option>
				
				<option value="file33">github.com/Checkmarx/kics/pkg/parser/terraform/converter/default.go (78.7%)</option>
				
				<option value="file34">github.com/Checkmarx/kics/pkg/parser/terraform/terraform.go (83.3%)</option>
				
				<option value="file35">github.com/Checkmarx/kics/pkg/parser/terraform/variables.go (92.2%)</option>
				
				<option value="file36">github.com/Checkmarx/kics/pkg/parser/yaml/parser.go (88.9%)</option>
				
				<option value="file37">github.com/Checkmarx/kics/pkg/report/commons.go (75.0%)</option>
				
				<option value="file38">github.com/Checkmarx/kics/pkg/report/html.go (88.9%)</option>
				
				<option value="file39">github.com/Checkmarx/kics/pkg/report/json.go (90.9%)</option>
				
				<option value="file40">github.com/Checkmarx/kics/pkg/report/sarif.go (83.3%)</option>
				
				<option value="file41">github.com/Checkmarx/kics/pkg/resolver/helm/helm.go (88.7%)</option>
				
				<option value="file42">github.com/Checkmarx/kics/pkg/resolver/helm/resolver.go (89.4%)</option>
				
				<option value="file43">github.com/Checkmarx/kics/pkg/resolver/resolver.go (90.5%)</option>
				
				<option value="file44">github.com/Checkmarx/kics/test/helpers.go (15.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package console

import (
        "fmt"

        "github.com/google/uuid"
        "github.com/rs/zerolog/log"
        "github.com/spf13/cobra"
)

// NewGenerateIDCmd creates a new instance of the generate-id Command
func NewGenerateIDCmd() *cobra.Command <span class="cov10" title="11">{
        return &amp;cobra.Command{
                Use:   "generate-id",
                Short: "Generates uuid for query",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov1" title="1">{
                        _, err := fmt.Fprintln(cmd.OutOrStdout(), uuid.New().String())
                        if err != nil </span><span class="cov0" title="0">{
                                log.Err(err).Msg("failed to get uuid")
                        }</span>
                        <span class="cov1" title="1">return err</span>
                },
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package helpers

import (
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "math"
        "os"
        "path/filepath"
        "strings"
        "sync"

        "github.com/BurntSushi/toml"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/Checkmarx/kics/pkg/report"
        "github.com/gookit/color"
        "github.com/hashicorp/hcl"
        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
        "gopkg.in/yaml.v3"
)

var reportGenerators = map[string]func(path, filename string, body interface{}) error{
        "json":  report.PrintJSONReport,
        "sarif": report.PrintSarifReport,
        "html":  report.PrintHTMLReport,
}

// ProgressBar represents a Progress
// Writer is the writer output for progress bar
type ProgressBar struct {
        Writer   io.Writer
        label    string
        space    int
        total    float64
        progress chan float64
}

// Printer wil print console output with colors
// Medium is for medium sevevity results
// High is for high sevevity results
// Low is for low sevevity results
// Info is for info sevevity results
// Success is for successful prints
// Line is the color to print the line with the vulnerability
// minVersion is a bool that if true will print the results output in a minimum version
type Printer struct {
        Medium  color.RGBColor
        High    color.RGBColor
        Low     color.RGBColor
        Info    color.RGBColor
        Success color.RGBColor
        Line    color.RGBColor
        minimal bool
}

// NewProgressBar initializes a new ProgressBar
// label is a string print before the progress bar
// total is the progress bar target (a.k.a 100%)
// space is the number of '=' characters on each side of the bar
// progress is a channel updating the current executed elements
func NewProgressBar(label string, space int, total float64, progress chan float64) ProgressBar <span class="cov3" title="4">{
        return ProgressBar{
                Writer:   os.Stdout,
                label:    label,
                space:    space,
                total:    total,
                progress: progress,
        }
}</span>

// Start starts to print a progress bar on console
// wg is a wait group to report when progress is done
func (p *ProgressBar) Start(wg *sync.WaitGroup) <span class="cov3" title="4">{
        defer wg.Done()
        if p.Writer != io.Discard </span><span class="cov2" title="3">{
                var firstHalfPercentage, secondHalfPercentage string
                const hundredPercent = 100
                formmatingString := "\r" + p.label + "[%s %4.1f%% %s]"
                for </span><span class="cov10" title="303">{
                        currentProgress, ok := &lt;-p.progress
                        if !ok || currentProgress &gt;= p.total </span><span class="cov2" title="3">{
                                fmt.Fprintf(p.Writer, formmatingString, strings.Repeat("=", p.space), 100.0, strings.Repeat("=", p.space))
                                break</span>
                        }

                        <span class="cov9" title="300">percentage := currentProgress / p.total * hundredPercent
                        convertedPercentage := int(math.Round(float64(p.space+p.space) / hundredPercent * math.Round(percentage)))
                        if percentage &gt;= hundredPercent/2 </span><span class="cov8" title="150">{
                                firstHalfPercentage = strings.Repeat("=", p.space)
                                secondHalfPercentage = strings.Repeat("=", convertedPercentage-p.space) +
                                        strings.Repeat(" ", 2*p.space-convertedPercentage)
                        }</span> else<span class="cov8" title="150"> {
                                secondHalfPercentage = strings.Repeat(" ", p.space)
                                firstHalfPercentage = strings.Repeat("=", convertedPercentage) +
                                        strings.Repeat(" ", p.space-convertedPercentage)
                        }</span>
                        <span class="cov9" title="300">fmt.Fprintf(p.Writer, formmatingString, firstHalfPercentage, percentage, secondHalfPercentage)</span>
                }
        }
        <span class="cov3" title="4">fmt.Println()</span>
}

// WordWrap Wraps text at the specified number of words
func WordWrap(s, identation string, limit int) string <span class="cov2" title="3">{
        if strings.TrimSpace(s) == "" </span><span class="cov1" title="1">{
                return s
        }</span>

        <span class="cov2" title="2">wordSlice := strings.Fields(s)
        var result string

        for len(wordSlice) &gt;= 1 </span><span class="cov2" title="3">{
                result = result + identation + strings.Join(wordSlice[:limit], " ") + "\r\n"

                wordSlice = wordSlice[limit:]
                if len(wordSlice) &lt; limit </span><span class="cov2" title="2">{
                        limit = len(wordSlice)
                }</span>
        }
        <span class="cov2" title="2">return result</span>
}

// PrintResult prints on output the summary results
func PrintResult(summary *model.Summary, failedQueries map[string]error, printer *Printer) error <span class="cov1" title="1">{
        log.Debug().Msg("helpers.PrintResult()")
        fmt.Printf("Files scanned: %d\n", summary.ScannedFiles)
        fmt.Printf("Parsed files: %d\n", summary.ParsedFiles)
        fmt.Printf("Queries loaded: %d\n", summary.TotalQueries)

        fmt.Printf("Queries failed to execute: %d\n\n", summary.FailedToExecuteQueries)
        for queryName, err := range failedQueries </span><span class="cov0" title="0">{
                fmt.Printf("\t- %s:\n", queryName)
                fmt.Printf("%s", WordWrap(err.Error(), "\t\t", 5))
        }</span>
        <span class="cov1" title="1">fmt.Printf("------------------------------------\n\n")
        for index := range summary.Queries </span><span class="cov2" title="2">{
                idx := len(summary.Queries) - index - 1
                fmt.Printf(
                        "%s, Severity: %s, Results: %d\n",
                        printer.PrintBySev(summary.Queries[idx].QueryName, string(summary.Queries[idx].Severity)),
                        printer.PrintBySev(string(summary.Queries[idx].Severity), string(summary.Queries[idx].Severity)),
                        len(summary.Queries[idx].Files),
                )
                if !printer.minimal </span><span class="cov0" title="0">{
                        fmt.Printf("Description: %s\n", summary.Queries[idx].Description)
                        fmt.Printf("Platform: %s\n\n", summary.Queries[idx].Platform)
                }</span>
                <span class="cov2" title="2">printFiles(&amp;summary.Queries[idx], printer)</span>
        }
        <span class="cov1" title="1">fmt.Printf("\nResults Summary:\n")
        printSeverityCounter(model.SeverityHigh, summary.SeveritySummary.SeverityCounters[model.SeverityHigh], printer.High)
        printSeverityCounter(model.SeverityMedium, summary.SeveritySummary.SeverityCounters[model.SeverityMedium], printer.Medium)
        printSeverityCounter(model.SeverityLow, summary.SeveritySummary.SeverityCounters[model.SeverityLow], printer.Low)
        printSeverityCounter(model.SeverityInfo, summary.SeveritySummary.SeverityCounters[model.SeverityInfo], printer.Info)
        fmt.Printf("TOTAL: %d\n\n", summary.SeveritySummary.TotalCounter)

        log.Info().Msgf("Files scanned: %d", summary.ScannedFiles)
        log.Info().Msgf("Parsed files: %d", summary.ParsedFiles)
        log.Info().Msgf("Queries loaded: %d", summary.TotalQueries)
        log.Info().Msgf("Queries failed to execute: %d", summary.FailedToExecuteQueries)
        log.Info().Msg("Inspector stopped")

        return nil</span>
}

func printSeverityCounter(severity string, counter int, printColor color.RGBColor) <span class="cov3" title="4">{
        fmt.Printf("%s: %d\n", printColor.Sprint(severity), counter)
}</span>

func printFiles(query *model.VulnerableQuery, printer *Printer) <span class="cov2" title="2">{
        for fileIdx := range query.Files </span><span class="cov2" title="3">{
                fmt.Printf("\t%s %s:%s\n", printer.PrintBySev(fmt.Sprintf("[%d]:", fileIdx+1), string(query.Severity)),
                        query.Files[fileIdx].FileName, printer.Success.Sprint(query.Files[fileIdx].Line))
                if !printer.minimal </span><span class="cov0" title="0">{
                        fmt.Println()
                        for _, line := range query.Files[fileIdx].VulnLines </span><span class="cov0" title="0">{
                                if line.Position == query.Files[fileIdx].Line </span><span class="cov0" title="0">{
                                        printer.Line.Printf("\t\t%03d: %s\n", line.Position, line.Line)
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Printf("\t\t%03d: %s\n", line.Position, line.Line)
                                }</span>
                        }
                        <span class="cov0" title="0">fmt.Print("\n\n")</span>
                }
        }
}

// CustomConsoleWriter creates an output to print log in a files
func CustomConsoleWriter(fileLogger *zerolog.ConsoleWriter) zerolog.ConsoleWriter <span class="cov0" title="0">{
        fileLogger.FormatLevel = func(i interface{}) string </span><span class="cov0" title="0">{
                return strings.ToUpper(fmt.Sprintf("| %-6s|", i))
        }</span>

        <span class="cov0" title="0">fileLogger.FormatFieldName = func(i interface{}) string </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s:", i)
        }</span>

        <span class="cov0" title="0">fileLogger.FormatErrFieldName = func(i interface{}) string </span><span class="cov0" title="0">{
                return "ERROR:"
        }</span>

        <span class="cov0" title="0">fileLogger.FormatFieldValue = func(i interface{}) string </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s", i)
        }</span>

        <span class="cov0" title="0">return *fileLogger</span>
}

// FileAnalyzer determines the type of extension in the passed config file by its content
func FileAnalyzer(path string) (string, error) <span class="cov4" title="11">{
        ostat, err := os.Open(filepath.Clean(path))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov4" title="11">rc, err := io.ReadAll(ostat)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov4" title="11">var temp map[string]interface{}

        if err := json.Unmarshal(rc, &amp;temp); err == nil </span><span class="cov2" title="2">{
                return "json", nil
        }</span>

        <span class="cov4" title="9">if err := yaml.Unmarshal(rc, &amp;temp); err == nil </span><span class="cov2" title="3">{
                return "yaml", nil
        }</span>

        <span class="cov3" title="6">if _, err := toml.Decode(string(rc), &amp;temp); err == nil </span><span class="cov2" title="2">{
                return "toml", nil
        }</span>

        <span class="cov3" title="4">if c, err := hcl.Parse(string(rc)); err == nil </span><span class="cov2" title="2">{
                if err = hcl.DecodeObject(&amp;temp, c); err == nil </span><span class="cov2" title="2">{
                        return "hcl", nil
                }</span>
        }

        <span class="cov2" title="2">return "", errors.New("invalid configuration file format")</span>
}

// GenerateReport execute each report function to generate report
func GenerateReport(path, filename string, body interface{}, formats []string) error <span class="cov2" title="2">{
        log.Debug().Msgf("helpers.GenerateReport()")
        var err error = nil
        for _, format := range formats </span><span class="cov2" title="2">{
                if err = reportGenerators[format](path, filename, body); err != nil </span><span class="cov1" title="1">{
                        log.Error().Msgf("Failed to generate %s report", format)
                        break</span>
                }
        }
        <span class="cov2" title="2">return err</span>
}

// GetExecutableDirectory - returns the path to the directory containing KICS executable
func GetExecutableDirectory() string <span class="cov2" title="2">{
        log.Debug().Msg("helpers.GetExecutableDirectory()")
        path, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
        }</span>
        <span class="cov2" title="2">return filepath.Dir(path)</span>
}

// GetDefaultQueryPath - returns the default query path
func GetDefaultQueryPath(queriesPath string) (string, error) <span class="cov2" title="2">{
        log.Debug().Msg("helpers.GetDefaultQueryPath()")
        executableDirPath := GetExecutableDirectory()
        queriesDirectory := filepath.Join(executableDirPath, queriesPath)
        if _, err := os.Stat(queriesDirectory); os.IsNotExist(err) </span><span class="cov2" title="2">{
                currentWorkDir, err := os.Getwd()
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov2" title="2">queriesDirectory = filepath.Join(currentWorkDir, queriesPath)
                if _, err := os.Stat(queriesDirectory); os.IsNotExist(err) </span><span class="cov1" title="1">{
                        return "", err
                }</span>
        }

        <span class="cov1" title="1">log.Debug().Msgf("Queries found in %s", queriesDirectory)
        return queriesDirectory, nil</span>
}

// ValidateReportFormats returns an error if output format is not supported
func ValidateReportFormats(formats []string) error <span class="cov2" title="2">{
        log.Debug().Msg("helpers.ValidateReportFormats()")

        validFormats := make([]string, 0, len(reportGenerators))
        for reportFormats := range reportGenerators </span><span class="cov3" title="6">{
                validFormats = append(validFormats, reportFormats)
        }</span>
        <span class="cov2" title="2">for _, format := range formats </span><span class="cov4" title="7">{
                if _, ok := reportGenerators[format]; !ok </span><span class="cov1" title="1">{
                        return fmt.Errorf(
                                fmt.Sprintf("Report format not supported: %s\nSupportted formats:\n  %s\n", format, strings.Join(validFormats, "\n")),
                        )
                }</span>
        }
        <span class="cov1" title="1">return nil</span>
}

// NewPrinter initializes a new Printer
func NewPrinter(minimal bool) *Printer <span class="cov2" title="2">{
        return &amp;Printer{
                Medium:  color.HEX("#ff7213"),
                High:    color.HEX("#bb2124"),
                Low:     color.HEX("#edd57e"),
                Success: color.HEX("#22bb33"),
                Info:    color.HEX("#5bc0de"),
                Line:    color.HEX("#f0ad4e"),
                minimal: minimal,
        }
}</span>

// PrintBySev will print the output with the specific severity color given the severity of the result
func (p *Printer) PrintBySev(content, sev string) string <span class="cov4" title="12">{
        switch strings.ToUpper(sev) </span>{
        case model.SeverityHigh:<span class="cov3" title="5">
                return p.High.Sprintf(content)</span>
        case model.SeverityMedium:<span class="cov3" title="4">
                return p.Medium.Sprintf(content)</span>
        case model.SeverityLow:<span class="cov1" title="1">
                return p.Low.Sprintf(content)</span>
        case model.SeverityInfo:<span class="cov1" title="1">
                return p.Info.Sprintf(content)</span>
        }
        <span class="cov1" title="1">return content</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package console

import (
        "context"
        "fmt"
        "os"
        "time"

        "github.com/Checkmarx/kics/internal/console/printer"
        "github.com/Checkmarx/kics/internal/constants"
        "github.com/getsentry/sentry-go"
        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

const (
        scanID   = "console"
        timeMult = 2
)

var (
        ctx = context.Background()

        verbose   bool
        logFile   bool
        logPath   string
        logLevel  string
        logFormat string
        noColor   bool
        silent    bool
        ci        bool

        warning []string
)

// NewKICSCmd creates a new instance of the kics Command
func NewKICSCmd() *cobra.Command <span class="cov10" title="11">{
        return &amp;cobra.Command{
                Use:   "kics",
                Short: constants.Fullname,
        }
}</span>

func initialize(rootCmd *cobra.Command) error <span class="cov10" title="11">{
        scanCmd := NewScanCmd()
        rootCmd.AddCommand(NewVersionCmd())
        rootCmd.AddCommand(NewGenerateIDCmd())
        rootCmd.AddCommand(scanCmd)
        rootCmd.AddCommand(NewListPlatformsCmd())
        rootCmd.PersistentFlags().BoolVarP(&amp;logFile,
                printer.LogFileFlag,
                printer.LogFileShorthand,
                false,
                "writes log messages to log file")
        rootCmd.PersistentFlags().StringVarP(&amp;logPath,
                printer.LogPathFlag,
                "",
                "",
                fmt.Sprintf("path to log files, (defaults to ${PWD}/%s)", constants.DefaultLogFile))
        rootCmd.PersistentFlags().StringVarP(&amp;logLevel,
                printer.LogLevelFlag,
                "",
                "INFO",
                "determines log level (TRACE,DEBUG,INFO,WARN,ERROR,FATAL)")
        rootCmd.PersistentFlags().StringVarP(&amp;logFormat,
                printer.LogFormatFlag,
                printer.LogFormatShorthand,
                printer.LogFormatPretty,
                fmt.Sprintf("determines log format (%s,%s)", printer.LogFormatPretty, printer.LogFormatJSON))
        rootCmd.PersistentFlags().BoolVarP(&amp;verbose,
                printer.VerboseFlag,
                printer.VerboseShorthand,
                false,
                "write logs to stdout too (mutually exclusive with silent)")
        rootCmd.PersistentFlags().BoolVarP(&amp;silent,
                printer.SilentFlag,
                printer.SilentShorthand,
                false,
                "silence stdout messages (mutually exclusive with verbose and ci)")
        rootCmd.PersistentFlags().BoolVarP(&amp;noColor,
                printer.NoColorFlag,
                "",
                false,
                "disable CLI color output")
        rootCmd.PersistentFlags().BoolVarP(&amp;ci,
                printer.CIFlag,
                "",
                false,
                "display only log messages to CLI output (mutually exclusive with silent)")

        err := rootCmd.PersistentFlags().MarkDeprecated(printer.LogFileFlag, "please use --log-path instead")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="11">if err := viper.BindPFlags(rootCmd.PersistentFlags()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="11">initScanCmd(scanCmd)
        if insertScanCmd(scanCmd) </span><span class="cov7" title="5">{
                warning = append(warning, "WARNING: for future versions use 'kics scan'")
                os.Args = append([]string{os.Args[0], "scan"}, os.Args[1:]...)
        }</span>

        <span class="cov10" title="11">return nil</span>
}

func insertScanCmd(scanCmd *cobra.Command) bool <span class="cov10" title="11">{
        if len(os.Args) &gt; 1 &amp;&amp; os.Args[1][0] == '-' </span><span class="cov7" title="5">{
                if os.Args[1][1] != '-' </span><span class="cov6" title="4">{
                        flag := os.Args[1][1:]
                        return scanCmd.Flags().ShorthandLookup(flag) != nil
                }</span>
                <span class="cov1" title="1">flag := os.Args[1][2:]
                return scanCmd.Flag(flag) != nil</span>
        }
        <span class="cov7" title="6">return false</span>
}

// Execute starts kics execution
func Execute() error <span class="cov10" title="11">{
        zerolog.SetGlobalLevel(zerolog.InfoLevel)

        rootCmd := NewKICSCmd()

        err := sentry.Init(sentry.ClientOptions{})
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err).Msg("Failed to initialize sentry")
        }</span>
        <span class="cov10" title="11">defer sentry.Flush(timeMult * time.Second)

        if err := initialize(rootCmd); err != nil </span><span class="cov0" title="0">{
                sentry.CaptureException(err)
                log.Err(err).Msg("Failed to initialize CLI")
                return err
        }</span>

        <span class="cov10" title="11">if err := rootCmd.ExecuteContext(ctx); err != nil </span><span class="cov3" title="2">{
                sentry.CaptureException(err)
                log.Err(err).Msg("Failed to run application")
                return err
        }</span>

        <span class="cov9" title="9">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package console

import (
        "fmt"

        "github.com/Checkmarx/kics/pkg/engine/source"
        "github.com/spf13/cobra"
)

// NewListPlatformsCmd creates a new instance of the list-platforms Command
func NewListPlatformsCmd() *cobra.Command <span class="cov10" title="11">{
        return &amp;cobra.Command{
                Use:   "list-platforms",
                Short: "List supported platforms",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov1" title="1">{
                        for _, v := range source.ListSupportedPlatforms() </span><span class="cov7" title="6">{
                                fmt.Fprintf(cmd.OutOrStdout(), "%s\n", v)
                        }</span>
                        <span class="cov1" title="1">return nil</span>
                },
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package printer

import (
        "errors"
        "io"
        "os"
        "path/filepath"
        "strconv"
        "strings"

        consoleHelpers "github.com/Checkmarx/kics/internal/console/helpers"
        "github.com/Checkmarx/kics/internal/constants"
        "github.com/gookit/color"
        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
        "github.com/spf13/pflag"
)

const (
        CIFlag             = "ci"
        LogFileFlag        = "log-file"
        LogFileShorthand   = "l"
        LogFormatFlag      = "log-format"
        LogFormatShorthand = "f"
        LogLevelFlag       = "log-level"
        LogPathFlag        = "log-path"
        NoColorFlag        = "no-color"
        SilentFlag         = "silent"
        SilentShorthand    = "s"
        VerboseFlag        = "verbose"
        VerboseShorthand   = "v"
        LogFormatJSON      = "json"
        LogFormatPretty    = "pretty"
)

var (
        optionsMap = map[string]func(opt interface{}, changed bool) error{
                CIFlag: func(opt interface{}, changed bool) error <span class="cov0" title="0">{
                        return nil
                }</span>,
                LogFileFlag:  LogFile,
                LogLevelFlag: LogLevel,
                LogPathFlag:  LogPath,
                NoColorFlag:  NoColor,
                SilentFlag: func(opt interface{}, changed bool) error <span class="cov0" title="0">{
                        return nil
                }</span>,
                VerboseFlag: Verbose,
                LogFormatFlag: func(opt interface{}, changed bool) error <span class="cov0" title="0">{
                        return nil
                }</span>,
        }

        consoleLogger = zerolog.ConsoleWriter{Out: io.Discard}
        fileLogger    = zerolog.ConsoleWriter{Out: io.Discard}

        outFileLogger    interface{}
        outConsoleLogger interface{}

        loggerFile interface{}
)

// SetupPrinter - configures stdout and log options with given FlagSet
func SetupPrinter(flags *pflag.FlagSet) error <span class="cov0" title="0">{
        err := validateFlags(flags)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for flagName, optionFunc := range optionsMap </span><span class="cov0" title="0">{
                f := flags.Lookup(flagName)
                switch f.Value.Type() </span>{
                case "string":<span class="cov0" title="0">
                        value := f.Value.String()
                        err = optionFunc(value, f.Changed)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                case "bool":<span class="cov0" title="0">
                        value, _ := strconv.ParseBool(f.Value.String())
                        err = optionFunc(value, f.Changed)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        // LogFormat needs to be the last option
        <span class="cov0" title="0">logFormat := strings.ToLower(flags.Lookup(LogFormatFlag).Value.String())
        err = LogFormat(logFormat, flags.Lookup(LogFormatFlag).Changed)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = Silent(getFlagValue(SilentFlag, flags), flags.Lookup(SilentFlag).Changed)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = CI(getFlagValue(CIFlag, flags), flags.Lookup(CIFlag).Changed)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func getFlagValue(flagName string, flags *pflag.FlagSet) bool <span class="cov0" title="0">{
        v, _ := strconv.ParseBool(flags.Lookup(flagName).Value.String())
        return v
}</span>

func validateFlags(flags *pflag.FlagSet) error <span class="cov0" title="0">{
        if getFlagValue(VerboseFlag, flags) &amp;&amp; getFlagValue(SilentFlag, flags) </span><span class="cov0" title="0">{
                return errors.New("can't provide 'silent' and 'verbose' flags simultaneously")
        }</span>

        <span class="cov0" title="0">if getFlagValue(VerboseFlag, flags) &amp;&amp; getFlagValue(CIFlag, flags) </span><span class="cov0" title="0">{
                return errors.New("can't provide 'verbose' and 'ci' flags simultaneously")
        }</span>

        <span class="cov0" title="0">if getFlagValue(CIFlag, flags) &amp;&amp; getFlagValue(SilentFlag, flags) </span><span class="cov0" title="0">{
                return errors.New("can't provide 'silent' and 'ci' flags simultaneously")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// NoColor - disables ASCII color codes
func NoColor(opt interface{}, changed bool) error <span class="cov1" title="1">{
        noColor := opt.(bool)
        if noColor </span><span class="cov1" title="1">{
                color.Disable()
                consoleLogger.NoColor = true
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// Verbose - redirects log entries to stdout
func Verbose(opt interface{}, changed bool) error <span class="cov1" title="1">{
        verbose := opt.(bool)
        if verbose </span><span class="cov1" title="1">{
                consoleLogger = zerolog.ConsoleWriter{Out: os.Stdout}
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// Silent - disables stdout output
func Silent(opt interface{}, changed bool) error <span class="cov1" title="1">{
        silent := opt.(bool)
        if silent </span><span class="cov1" title="1">{
                color.SetOutput(io.Discard)
                os.Stdout = nil
                log.Logger = log.Output(zerolog.MultiLevelWriter(io.Discard, outFileLogger.(io.Writer)))
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// CI - enable only log messages to CLI output
func CI(opt interface{}, changed bool) error <span class="cov1" title="1">{
        ci := opt.(bool)
        if ci </span><span class="cov1" title="1">{
                color.SetOutput(io.Discard)
                log.Logger = log.Output(zerolog.MultiLevelWriter(outConsoleLogger.(io.Writer), outFileLogger.(io.Writer)))
                os.Stdout = nil
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// LogFormat - configures the logs format (JSON,pretty).
func LogFormat(opt interface{}, changed bool) error <span class="cov6" title="3">{
        logFormat := opt.(string)
        if logFormat == LogFormatJSON </span><span class="cov1" title="1">{
                log.Logger = log.Output(zerolog.MultiLevelWriter(os.Stdout, loggerFile.(io.Writer)))
                outFileLogger = loggerFile
                outConsoleLogger = os.Stdout
        }</span> else<span class="cov4" title="2"> if logFormat == LogFormatPretty </span><span class="cov1" title="1">{
                fileLogger = consoleHelpers.CustomConsoleWriter(&amp;zerolog.ConsoleWriter{Out: loggerFile.(io.Writer), NoColor: true})
                log.Logger = log.Output(zerolog.MultiLevelWriter(consoleLogger, fileLogger))
                outFileLogger = fileLogger
                outConsoleLogger = zerolog.ConsoleWriter{Out: os.Stdout, NoColor: true}
        }</span> else<span class="cov1" title="1"> {
                return errors.New("invalid log format")
        }</span>
        <span class="cov4" title="2">return nil</span>
}

// LogPath - sets the log files location
func LogPath(opt interface{}, changed bool) error <span class="cov4" title="2">{
        logPath := opt.(string)
        var err error
        if !changed </span><span class="cov0" title="0">{
                if loggerFile == nil </span><span class="cov0" title="0">{
                        loggerFile = io.Discard
                        return nil
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov4" title="2">if logPath == "" </span><span class="cov1" title="1">{
                logPath, err = getDefaultLogPath()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov4" title="2">loggerFile, err = os.OpenFile(filepath.Clean(logPath), os.O_APPEND|os.O_CREATE|os.O_WRONLY, os.ModePerm)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// LogFile - enables write to log file
func LogFile(opt interface{}, changed bool) error <span class="cov1" title="1">{
        logFile := opt.(bool)
        if logFile </span><span class="cov1" title="1">{
                logPath, err := getDefaultLogPath()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov1" title="1">loggerFile, err = os.OpenFile(filepath.Clean(logPath), os.O_APPEND|os.O_CREATE|os.O_WRONLY, os.ModePerm)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov1" title="1">fileLogger = consoleHelpers.CustomConsoleWriter(&amp;zerolog.ConsoleWriter{Out: loggerFile.(io.Writer), NoColor: true})</span>
        }
        <span class="cov1" title="1">return nil</span>
}

// LogLevel - sets log level
func LogLevel(opt interface{}, changed bool) error <span class="cov10" title="7">{
        logLevel := opt.(string)
        switch strings.ToUpper(logLevel) </span>{
        case "TRACE":<span class="cov1" title="1">
                zerolog.SetGlobalLevel(zerolog.TraceLevel)</span>
        case "DEBUG":<span class="cov1" title="1">
                zerolog.SetGlobalLevel(zerolog.DebugLevel)</span>
        case "INFO":<span class="cov1" title="1">
                zerolog.SetGlobalLevel(zerolog.InfoLevel)</span>
        case "WARN":<span class="cov1" title="1">
                zerolog.SetGlobalLevel(zerolog.WarnLevel)</span>
        case "ERROR":<span class="cov1" title="1">
                zerolog.SetGlobalLevel(zerolog.ErrorLevel)</span>
        case "FATAL":<span class="cov1" title="1">
                zerolog.SetGlobalLevel(zerolog.FatalLevel)</span>
        default:<span class="cov1" title="1">
                return errors.New("invalid log level")</span>
        }
        <span class="cov9" title="6">return nil</span>
}

func getDefaultLogPath() (string, error) <span class="cov4" title="2">{
        currentWorkDir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov4" title="2">return filepath.Join(currentWorkDir, constants.DefaultLogFile), nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package console

import (
        _ "embed" // Embed kics CLI img
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"

        consoleHelpers "github.com/Checkmarx/kics/internal/console/helpers"
        internalPrinter "github.com/Checkmarx/kics/internal/console/printer"
        "github.com/Checkmarx/kics/internal/constants"
        "github.com/Checkmarx/kics/internal/storage"
        "github.com/Checkmarx/kics/internal/tracker"
        "github.com/Checkmarx/kics/pkg/engine"
        "github.com/Checkmarx/kics/pkg/engine/provider"
        "github.com/Checkmarx/kics/pkg/engine/source"
        "github.com/Checkmarx/kics/pkg/kics"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/Checkmarx/kics/pkg/parser"
        dockerParser "github.com/Checkmarx/kics/pkg/parser/docker"
        jsonParser "github.com/Checkmarx/kics/pkg/parser/json"
        terraformParser "github.com/Checkmarx/kics/pkg/parser/terraform"
        yamlParser "github.com/Checkmarx/kics/pkg/parser/yaml"
        "github.com/Checkmarx/kics/pkg/resolver"
        "github.com/Checkmarx/kics/pkg/resolver/helm"
        "github.com/getsentry/sentry-go"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
        "github.com/spf13/cobra"
        "github.com/spf13/pflag"
        "github.com/spf13/viper"
)

var (
        path              string
        queryPath         string
        outputPath        string
        payloadPath       string
        excludeCategories []string
        excludePath       []string
        excludeIDs        []string
        excludeResults    []string
        reportFormats     []string
        cfgFile           string

        noProgress   bool
        types        []string
        min          bool
        previewLines int
        //go:embed img/kics-console
        banner string
)

const (
        scanCommandStr          = "scan"
        pathFlag                = "path"
        pathFlagShorthand       = "p"
        configFlag              = "config"
        queriesPathShorthand    = "q"
        outputPathFlag          = "output-path"
        outputPathShorthand     = "o"
        reportFormatsFlag       = "report-formats"
        previewLinesFlag        = "preview-lines"
        excludePathsFlag        = "exclude-paths"
        excludePathsShorthand   = "e"
        minimalUIFlag           = "minimal-ui"
        payloadPathFlag         = "payload-path"
        payloadPathShorthand    = "d"
        typeFlag                = "type"
        typeShorthand           = "t"
        noProgressFlag          = "no-progress"
        excludeQueriesFlag      = "exclude-queries"
        excludeResultsFlag      = "exclude-results"
        excludeResutlsShorthand = "x"
        excludeCategoriesFlag   = "exclude-categories"
        queriesPathCmdName      = "queries-path"
)

// NewScanCmd creates a new instance of the scan Command
func NewScanCmd() *cobra.Command <span class="cov4" title="11">{
        return &amp;cobra.Command{
                Use:   scanCommandStr,
                Short: "Executes a scan analysis",
                PersistentPreRunE: func(cmd *cobra.Command, args []string) error </span><span class="cov4" title="8">{
                        err := initializeConfig(cmd)
                        if err != nil </span><span class="cov1" title="1">{
                                return err
                        }</span>
                        <span class="cov4" title="7">err = internalPrinter.SetupPrinter(cmd.InheritedFlags())
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov4" title="7">return nil</span>
                },
                RunE: func(cmd *cobra.Command, args []string) error <span class="cov4" title="7">{
                        changedDefaultQueryPath := cmd.Flags().Lookup(queriesPathCmdName).Changed
                        return scan(changedDefaultQueryPath)
                }</span>,
        }
}

func initializeConfig(cmd *cobra.Command) error <span class="cov4" title="8">{
        log.Debug().Msg("console.initializeConfig()")

        v := viper.New()
        v.SetEnvPrefix("KICS")
        v.AutomaticEnv()
        errBind := bindFlags(cmd, v)
        if errBind != nil </span><span class="cov0" title="0">{
                return errBind
        }</span>

        <span class="cov4" title="8">if cfgFile == "" </span><span class="cov3" title="6">{
                configpath := path
                info, err := os.Stat(path)
                if err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov3" title="6">if !info.IsDir() </span><span class="cov3" title="5">{
                        configpath = filepath.Dir(path)
                }</span>
                <span class="cov3" title="6">_, err = os.Stat(filepath.ToSlash(filepath.Join(configpath, constants.DefaultConfigFilename)))
                if err != nil </span><span class="cov3" title="6">{
                        if os.IsNotExist(err) </span><span class="cov3" title="6">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
                <span class="cov0" title="0">cfgFile = filepath.ToSlash(filepath.Join(path, constants.DefaultConfigFilename))</span>
        }

        <span class="cov2" title="2">base := filepath.Base(cfgFile)
        v.SetConfigName(base)
        v.AddConfigPath(filepath.Dir(cfgFile))
        ext, err := consoleHelpers.FileAnalyzer(cfgFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov2" title="2">v.SetConfigType(ext)
        if err := v.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov2" title="2">errBind = bindFlags(cmd, v)
        if errBind != nil </span><span class="cov1" title="1">{
                return errBind
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func bindFlags(cmd *cobra.Command, v *viper.Viper) error <span class="cov4" title="10">{
        log.Debug().Msg("console.bindFlags()")
        settingsMap := v.AllSettings()
        cmd.Flags().VisitAll(func(f *pflag.Flag) </span><span class="cov10" title="230">{
                settingsMap[f.Name] = true
                if strings.Contains(f.Name, "-") </span><span class="cov9" title="160">{
                        envVarSuffix := strings.ToUpper(strings.ReplaceAll(f.Name, "-", "_"))
                        variableName := fmt.Sprintf("%s_%s", "KICS", envVarSuffix)
                        if err := v.BindEnv(f.Name, variableName); err != nil </span><span class="cov0" title="0">{
                                log.Err(err).Msg("Failed to bind Viper flags")
                        }</span>
                }
                <span class="cov10" title="230">if !f.Changed &amp;&amp; v.IsSet(f.Name) </span><span class="cov3" title="6">{
                        val := v.Get(f.Name)
                        setBoundFlags(f.Name, val, cmd)
                }</span>
        })
        <span class="cov4" title="10">for key, val := range settingsMap </span><span class="cov9" title="223">{
                if val == true </span><span class="cov9" title="222">{
                        continue</span>
                } else<span class="cov1" title="1"> {
                        return fmt.Errorf("unknown configuration key: '%s'\nShowing help for '%s' command", key, cmd.Name())
                }</span>
        }
        <span class="cov4" title="9">return nil</span>
}

func setBoundFlags(flagName string, val interface{}, cmd *cobra.Command) <span class="cov3" title="6">{
        switch t := val.(type) </span>{
        case []interface{}:<span class="cov2" title="2">
                var paramSlice []string
                for _, param := range t </span><span class="cov3" title="4">{
                        paramSlice = append(paramSlice, param.(string))
                }</span>
                <span class="cov2" title="2">valStr := strings.Join(paramSlice, ",")
                if err := cmd.Flags().Set(flagName, fmt.Sprintf("%v", valStr)); err != nil </span><span class="cov0" title="0">{
                        log.Err(err).Msg("Failed to get Viper flags")
                }</span>
        default:<span class="cov3" title="4">
                if err := cmd.Flags().Set(flagName, fmt.Sprintf("%v", val)); err != nil </span><span class="cov0" title="0">{
                        log.Err(err).Msg("Failed to get Viper flags")
                }</span>
        }
}

func initScanCmd(scanCmd *cobra.Command) <span class="cov4" title="11">{
        scanCmd.Flags().StringVarP(&amp;path,
                pathFlag,
                pathFlagShorthand,
                "",
                "path or directory path to scan")
        scanCmd.Flags().StringVarP(&amp;cfgFile,
                configFlag,
                "",
                "",
                "path to configuration file")
        scanCmd.Flags().StringVarP(
                &amp;queryPath,
                queriesPathCmdName,
                queriesPathShorthand,
                "./assets/queries",
                "path to directory with queries",
        )
        scanCmd.Flags().StringVarP(&amp;outputPath,
                outputPathFlag,
                outputPathShorthand,
                "",
                "directory path to store reports")
        scanCmd.Flags().StringSliceVarP(&amp;reportFormats,
                reportFormatsFlag,
                "",
                []string{},
                "formats in which the results will be exported (json, sarif, html)",
        )
        scanCmd.Flags().IntVarP(&amp;previewLines,
                previewLinesFlag,
                "",
                3,
                "number of lines to be display in CLI results (min: 1, max: 30)")
        scanCmd.Flags().StringVarP(&amp;payloadPath,
                payloadPathFlag,
                payloadPathShorthand,
                "",
                "path to store internal representation JSON file")
        scanCmd.Flags().StringSliceVarP(&amp;excludePath,
                excludePathsFlag,
                excludePathsShorthand,
                []string{},
                "exclude paths from scan\nsupports glob and can be provided multiple times or as a quoted comma separated string"+
                        "\nexample: './shouldNotScan/*,somefile.txt'",
        )
        scanCmd.Flags().BoolVarP(&amp;min,
                minimalUIFlag,
                "",
                false,
                "simplified version of CLI output")
        scanCmd.Flags().StringSliceVarP(&amp;types,
                typeFlag,
                typeShorthand,
                []string{""},
                "case insensitive list of platform types to scan\n"+
                        fmt.Sprintf("(%s)", strings.Join(source.ListSupportedPlatforms(), ", ")))
        scanCmd.Flags().BoolVarP(&amp;noProgress,
                noProgressFlag,
                "",
                false,
                "hides the progress bar")
        scanCmd.Flags().StringSliceVarP(&amp;excludeIDs,
                excludeQueriesFlag,
                "",
                []string{},
                "exclude queries by providing the query ID\n"+
                        "can be provided multiple times or as a comma separated string\n"+
                        "example: 'e69890e6-fce5-461d-98ad-cb98318dfc96,4728cd65-a20c-49da-8b31-9c08b423e4db'",
        )
        scanCmd.Flags().StringSliceVarP(&amp;excludeResults,
                excludeResultsFlag,
                excludeResutlsShorthand,
                []string{},
                "exclude results by providing the similarity ID of a result\n"+
                        "can be provided multiple times or as a comma separated string\n"+
                        "example: 'fec62a97d569662093dbb9739360942f...,31263s5696620s93dbb973d9360942fc2a...'",
        )
        scanCmd.Flags().StringSliceVarP(&amp;excludeCategories,
                excludeCategoriesFlag,
                "",
                []string{},
                "exclude categories by providing its name\n"+
                        "can be provided multiple times or as a comma separated string\n"+
                        "example: 'Access control,Best practices'",
        )

        if err := scanCmd.MarkFlagRequired("path"); err != nil </span><span class="cov0" title="0">{
                sentry.CaptureException(err)
                log.Err(err).Msg("Failed to add command required flags")
        }</span>
}

func getFileSystemSourceProvider() (*provider.FileSystemSourceProvider, error) <span class="cov3" title="6">{
        var excludePaths []string
        if payloadPath != "" </span><span class="cov1" title="1">{
                excludePaths = append(excludePaths, payloadPath)
        }</span>

        <span class="cov3" title="6">if len(excludePath) &gt; 0 </span><span class="cov1" title="1">{
                excludePaths = append(excludePaths, excludePath...)
        }</span>

        <span class="cov3" title="6">absPath, err := filepath.Abs(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov3" title="6">filesSource, err := provider.NewFileSystemSourceProvider(absPath, excludePaths)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov3" title="6">return filesSource, nil</span>
}

func getExcludeResultsMap(excludeResults []string) map[string]bool <span class="cov3" title="6">{
        excludeResultsMap := make(map[string]bool)
        for _, er := range excludeResults </span><span class="cov1" title="1">{
                excludeResultsMap[er] = true
        }</span>
        <span class="cov3" title="6">return excludeResultsMap</span>
}

func createInspector(t engine.Tracker, querySource source.QueriesSource) (*engine.Inspector, error) <span class="cov3" title="6">{
        excludeResultsMap := getExcludeResultsMap(excludeResults)

        excludeQueries := source.ExcludeQueries{
                ByIDs:        excludeIDs,
                ByCategories: excludeCategories,
        }

        inspector, err := engine.NewInspector(ctx, querySource, engine.DefaultVulnerabilityBuilder, t, excludeQueries, excludeResultsMap)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov3" title="6">return inspector, nil</span>
}

func createService(inspector *engine.Inspector,
        t kics.Tracker,
        store kics.Storage,
        querySource source.FilesystemSource) (*kics.Service, error) <span class="cov3" title="6">{
        filesSource, err := getFileSystemSourceProvider()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov3" title="6">combinedParser, err := parser.NewBuilder().
                Add(&amp;jsonParser.Parser{}).
                Add(&amp;yamlParser.Parser{}).
                Add(terraformParser.NewDefault()).
                Add(&amp;dockerParser.Parser{}).
                Build(querySource.Types)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // combinedResolver to be used to resolve files and templates
        <span class="cov3" title="6">combinedResolver, err := resolver.NewBuilder().
                Add(&amp;helm.Resolver{}).
                Build()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov3" title="6">return &amp;kics.Service{
                SourceProvider: filesSource,
                Storage:        store,
                Parser:         combinedParser,
                Inspector:      inspector,
                Tracker:        t,
                Resolver:       combinedResolver,
        }, nil</span>
}

func scan(changedDefaultQueryPath bool) error <span class="cov4" title="7">{
        log.Debug().Msg("console.scan()")

        for _, warn := range warning </span><span class="cov6" title="21">{
                log.Warn().Msgf(warn)
        }</span>

        <span class="cov4" title="7">printer := consoleHelpers.NewPrinter(min)
        printer.Success.Printf("\n%s\n", banner)

        versionMsg := fmt.Sprintf("\nScanning with %s\n\n", getVersion())
        fmt.Println(versionMsg)
        log.Info().Msgf(strings.ReplaceAll(versionMsg, "\n", ""))

        scanStartTime := time.Now()

        t, err := tracker.NewTracker(previewLines)
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return err
        }</span>

        <span class="cov4" title="7">if changedDefaultQueryPath </span><span class="cov3" title="6">{
                log.Debug().Msgf("Trying to load queries from %s", queryPath)
        }</span> else<span class="cov1" title="1"> {
                log.Debug().Msgf("Looking for queries in executable path and in current work directory")
                queryPath, err = consoleHelpers.GetDefaultQueryPath(queryPath)
                if err != nil </span><span class="cov1" title="1">{
                        return errors.Wrap(err, "unable to find queries")
                }</span>
        }

        <span class="cov3" title="6">querySource := source.NewFilesystemSource(queryPath, types)
        store := storage.NewMemoryStorage()

        inspector, err := createInspector(t, querySource)
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return err
        }</span>

        <span class="cov3" title="6">service, err := createService(inspector, t, store, *querySource)
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return err
        }</span>

        <span class="cov3" title="6">if scanErr := service.StartScan(ctx, scanID, noProgress); scanErr != nil </span><span class="cov0" title="0">{
                log.Err(scanErr)
                return scanErr
        }</span>

        <span class="cov3" title="6">results, err := store.GetVulnerabilities(ctx, scanID)
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return err
        }</span>

        <span class="cov3" title="6">files, err := store.GetFiles(ctx, scanID)
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return err
        }</span>

        <span class="cov3" title="6">elapsed := time.Since(scanStartTime)

        summary := getSummary(t, results)

        if err := resolveOutputs(&amp;summary, files.Combine(), inspector.GetFailedQueries(), printer); err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return err
        }</span>

        <span class="cov3" title="6">elapsedStrFormat := "Scan duration: %v\n"
        fmt.Printf(elapsedStrFormat, elapsed)
        log.Info().Msgf(elapsedStrFormat, elapsed)

        if summary.FailedToExecuteQueries &gt; 0 </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>

        <span class="cov3" title="6">return nil</span>
}

func getSummary(t *tracker.CITracker, results []model.Vulnerability) model.Summary <span class="cov3" title="6">{
        counters := model.Counters{
                ScannedFiles:           t.FoundFiles,
                ParsedFiles:            t.ParsedFiles,
                TotalQueries:           t.LoadedQueries,
                FailedToExecuteQueries: t.LoadedQueries - t.ExecutedQueries,
                FailedSimilarityID:     t.FailedSimilarityID,
        }

        return model.CreateSummary(counters, results, scanID)
}</span>

func resolveOutputs(
        summary *model.Summary,
        documents model.Documents,
        failedQueries map[string]error,
        printer *consoleHelpers.Printer,
) error <span class="cov3" title="6">{
        log.Debug().Msg("console.resolveOutputs()")

        if err := printOutput(payloadPath, "payload", documents, []string{"json"}); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="6">if err := printOutput(outputPath, "results", summary, reportFormats); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="6">return consoleHelpers.PrintResult(summary, failedQueries, printer)</span>
}

func printOutput(outputPath, filename string, body interface{}, formats []string) error <span class="cov5" title="12">{
        log.Debug().Msg("console.printOutput()")
        if outputPath == "" </span><span class="cov4" title="10">{
                return nil
        }</span>

        <span class="cov2" title="2">if strings.Contains(outputPath, ".") </span><span class="cov2" title="2">{
                if len(formats) == 0 &amp;&amp; filepath.Ext(outputPath) != "" </span><span class="cov1" title="1">{
                        formats = []string{filepath.Ext(outputPath)[1:]}
                }</span>
                <span class="cov2" title="2">if len(formats) == 1 &amp;&amp; strings.HasSuffix(outputPath, formats[0]) </span><span class="cov2" title="2">{
                        filename = filepath.Base(outputPath)
                        outputPath = filepath.Dir(outputPath)
                }</span>
        }

        <span class="cov2" title="2">log.Debug().Msgf("Output formats provided [%v]", strings.Join(formats, ","))

        err := consoleHelpers.ValidateReportFormats(formats)
        if err == nil </span><span class="cov2" title="2">{
                err = consoleHelpers.GenerateReport(outputPath, filename, body, formats)
        }</span>
        <span class="cov2" title="2">return err</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package console

import (
        "fmt"

        "github.com/Checkmarx/kics/internal/constants"
        "github.com/spf13/cobra"
)

// NewVersionCmd creates a new instance of the version Command
func NewVersionCmd() *cobra.Command <span class="cov10" title="11">{
        return &amp;cobra.Command{
                Use:   "version",
                Short: "Displays the current version",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov1" title="1">{
                        fmt.Fprintf(cmd.OutOrStdout(), "%s\n", getVersion())
                        return nil
                }</span>,
        }
}

func getVersion() string <span class="cov8" title="8">{
        return fmt.Sprintf("%s %s", constants.Fullname, constants.Version)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package storage

import (
        "context"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/rs/zerolog/log"
)

// MemoryStorage is scans' results representation
type MemoryStorage struct {
        vulnerabilities []model.Vulnerability
        allFiles        model.FileMetadatas
}

// SaveFile adds a new file metadata to files collection
func (m *MemoryStorage) SaveFile(_ context.Context, metadata *model.FileMetadata) error <span class="cov8" title="1">{
        m.allFiles = append(m.allFiles, *metadata)
        return nil
}</span>

// GetFiles returns a collection of files saved on MemoryStorage
func (m *MemoryStorage) GetFiles(_ context.Context, _ string) (model.FileMetadatas, error) <span class="cov8" title="1">{
        return m.allFiles, nil
}</span>

// SaveVulnerabilities adds a list of vulnerabilities to vulnerabilities collection
func (m *MemoryStorage) SaveVulnerabilities(_ context.Context, vulnerabilities []model.Vulnerability) error <span class="cov8" title="1">{
        m.vulnerabilities = append(m.vulnerabilities, vulnerabilities...)
        return nil
}</span>

// GetVulnerabilities returns a collection of vulnerabilities saved on MemoryStorage
func (m *MemoryStorage) GetVulnerabilities(_ context.Context, _ string) ([]model.Vulnerability, error) <span class="cov8" title="1">{
        return m.vulnerabilities, nil
}</span>

// GetScanSummary is not supported by MemoryStorage
func (m *MemoryStorage) GetScanSummary(_ context.Context, _ []string) ([]model.SeveritySummary, error) <span class="cov8" title="1">{
        return nil, nil
}</span>

// NewMemoryStorage creates a new MemoryStorage empty and returns it
func NewMemoryStorage() *MemoryStorage <span class="cov8" title="1">{
        log.Debug().Msg("storage.NewMemoryStorage()")
        return &amp;MemoryStorage{
                allFiles:        make(model.FileMetadatas, 0),
                vulnerabilities: make([]model.Vulnerability, 0),
        }
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package tracker

import (
        "fmt"

        "github.com/Checkmarx/kics/internal/constants"
)

// CITracker contains information of how many queries were loaded and executed
// and how many files were found and executed
type CITracker struct {
        LoadedQueries      int
        ExecutedQueries    int
        FoundFiles         int
        ParsedFiles        int
        FailedSimilarityID int
        lines              int
}

// NewTracker will create a new instance of a tracker with the number of lines to display in results output
// number of lines can not be smaller than 1
func NewTracker(previewLines int) (*CITracker, error) <span class="cov10" title="2">{
        if previewLines &lt; constants.MinimumPreviewLines || previewLines &gt; constants.MaximumPreviewLines </span><span class="cov1" title="1">{
                return &amp;CITracker{},
                        fmt.Errorf("output lines minimum is %v and maximum is %v", constants.MinimumPreviewLines, constants.MaximumPreviewLines)
        }</span>
        <span class="cov1" title="1">return &amp;CITracker{
                lines: previewLines,
        }, nil</span>
}

// GetOutputLines returns the number of lines to display in results output
func (c *CITracker) GetOutputLines() int <span class="cov1" title="1">{
        return c.lines
}</span>

// TrackQueryLoad adds a loaded query
func (c *CITracker) TrackQueryLoad(queryAggregation int) <span class="cov1" title="1">{
        c.LoadedQueries += queryAggregation
}</span>

// TrackQueryExecution adds a query executed
func (c *CITracker) TrackQueryExecution(queryAggregation int) <span class="cov1" title="1">{
        c.ExecutedQueries += queryAggregation
}</span>

// TrackFileFound adds a found file to be scanned
func (c *CITracker) TrackFileFound() <span class="cov1" title="1">{
        c.FoundFiles++
}</span>

// TrackFileParse adds a successful parsed file to be scanned
func (c *CITracker) TrackFileParse() <span class="cov1" title="1">{
        c.ParsedFiles++
}</span>

// FailedDetectLine - queries that fail to detect line are counted as failed to execute queries
func (c *CITracker) FailedDetectLine() <span class="cov1" title="1">{
        c.ExecutedQueries--
}</span>

// FailedComputeSimilarityID - queries that failed to compute similarity ID
func (c *CITracker) FailedComputeSimilarityID() <span class="cov1" title="1">{
        c.FailedSimilarityID++
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package engine

import (
        "fmt"
        "strings"

        build "github.com/Checkmarx/kics/pkg/builder/model"
        commentParser "github.com/Checkmarx/kics/pkg/builder/parser/comment"
        tagParser "github.com/Checkmarx/kics/pkg/builder/parser/tag"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/hashicorp/hcl/v2"
        "github.com/hashicorp/hcl/v2/hclsyntax"
        "github.com/rs/zerolog/log"
        "github.com/zclconf/go-cty/cty"
        ctyConvert "github.com/zclconf/go-cty/cty/convert"
)

const resourceLabelsCount = 2

// Engine contains the conditions of rules and comments positions
type Engine struct {
        commentParser *commentParser.Parser
        conditions    []build.Condition
}

// Run parses files and execute engine.Run
func Run(src []byte, filename string) ([]build.Rule, error) <span class="cov1" title="1">{
        cp, err := commentParser.NewParser(src, filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">file, diags := hclsyntax.ParseConfig(src, filename, hcl.Pos{Byte: 0, Line: 1, Column: 1})
        if diags != nil &amp;&amp; diags.HasErrors() </span><span class="cov0" title="0">{
                return nil, diags.Errs()[0]
        }</span>
        <span class="cov1" title="1">if file == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid parse result")
        }</span>

        <span class="cov1" title="1">e := &amp;Engine{
                commentParser: cp,
        }

        return e.Run(file.Body.(*hclsyntax.Body))</span>
}

// Run initializes rules for Engine and returns it
func (e *Engine) Run(body *hclsyntax.Body) ([]build.Rule, error) <span class="cov1" title="1">{
        e.conditions = make([]build.Condition, 0)
        if err := e.walkBody(body, []build.PathItem{}); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">rules := make([]build.Rule, 0)
        conditionGroups := make(map[string][]build.Condition)
        for _, condition := range e.conditions </span><span class="cov1" title="1">{
                group, ok := condition.AttrAsString("group")
                if !ok </span><span class="cov1" title="1">{
                        rules = append(rules, build.Rule{
                                Conditions: []build.Condition{condition},
                        })
                        continue</span>
                }

                <span class="cov0" title="0">conditionGroups[group] = append(conditionGroups[group], condition)</span>
        }

        <span class="cov1" title="1">for _, conditionGroup := range conditionGroups </span><span class="cov0" title="0">{
                rules = append(rules, build.Rule{
                        Conditions: conditionGroup,
                })
        }</span>
        <span class="cov1" title="1">return rules, nil</span>
}

func (e *Engine) walkBody(body *hclsyntax.Body, walkHistory []build.PathItem) error <span class="cov5" title="3">{
        for _, attribute := range body.Attributes </span><span class="cov6" title="4">{
                if err := e.walkAttribute(attribute, walkHistory); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov5" title="3">for _, block := range body.Blocks </span><span class="cov3" title="2">{
                if err := e.walkBlock(block, walkHistory); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov5" title="3">return nil</span>
}

func (e *Engine) walkBlock(block *hclsyntax.Block, walkHistory []build.PathItem) error <span class="cov3" title="2">{
        if len(block.Labels) == resourceLabelsCount </span><span class="cov1" title="1">{
                walkHistory = append(walkHistory,
                        build.PathItem{Type: build.PathTypeResource, Name: block.Type},
                        build.PathItem{Type: build.PathTypeResourceType, Name: block.Labels[0]},
                        build.PathItem{Type: build.PathTypeResourceName, Name: block.Type},
                )
        }</span> else<span class="cov1" title="1"> {
                walkHistory = append(walkHistory, build.PathItem{Type: build.PathTypeDefault, Name: block.Type})
        }</span>

        <span class="cov3" title="2">e.checkComment(block.Range(), walkHistory, nil)

        return e.walkBody(block.Body, walkHistory)</span>
}

func (e *Engine) walkAttribute(attr *hclsyntax.Attribute, walkHistory []build.PathItem) error <span class="cov6" title="4">{
        walkHistory = append(walkHistory, build.PathItem{Type: build.PathTypeDefault, Name: attr.Name})

        switch exp := attr.Expr.(type) </span>{
        case *hclsyntax.TemplateExpr,
                *hclsyntax.TemplateWrapExpr,
                *hclsyntax.LiteralValueExpr,
                *hclsyntax.ScopeTraversalExpr:<span class="cov5" title="3">

                v, err := e.expToString(attr.Expr)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov5" title="3">e.checkComment(attr.Range(), walkHistory, &amp;v)</span>
        case *hclsyntax.ObjectConsExpr:<span class="cov1" title="1">
                e.checkComment(attr.Range(), walkHistory, nil)

                for _, item := range exp.Items </span><span class="cov3" title="2">{
                        if err := e.walkConstantItem(item, walkHistory); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        default:<span class="cov0" title="0">
                e.checkComment(attr.Range(), walkHistory, nil)</span>
        }

        <span class="cov6" title="4">return nil</span>
}

func (e *Engine) expToString(expr hclsyntax.Expression) (string, error) <span class="cov10" title="9">{
        switch t := expr.(type) </span>{
        case *hclsyntax.LiteralValueExpr:<span class="cov1" title="1">
                s, err := ctyConvert.Convert(t.Val, cty.String)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov1" title="1">return s.AsString(), nil</span>
        case *hclsyntax.TemplateExpr:<span class="cov6" title="4">
                if t.IsStringLiteral() </span><span class="cov6" title="4">{
                        v, err := t.Value(nil)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov6" title="4">return v.AsString(), nil</span>
                }
                <span class="cov0" title="0">builder, err := e.buildString(t.Parts)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                <span class="cov0" title="0">return builder.String(), nil</span>
        case *hclsyntax.TemplateWrapExpr:<span class="cov0" title="0">
                return e.expToString(t.Wrapped)</span>
        case *hclsyntax.ObjectConsKeyExpr:<span class="cov3" title="2">
                return e.expToString(t.Wrapped)</span>
        case *hclsyntax.ScopeTraversalExpr:<span class="cov3" title="2">
                var items []string
                for _, part := range t.Traversal </span><span class="cov3" title="2">{
                        switch tt := part.(type) </span>{
                        case hcl.TraverseAttr:<span class="cov0" title="0">
                                items = append(items, tt.Name)</span>
                        case hcl.TraverseRoot:<span class="cov3" title="2">
                                items = append(items, tt.Name)</span>
                        case hcl.TraverseIndex:<span class="cov0" title="0">
                                items = append(items, tt.Key.AsString())</span>
                        }
                }
                <span class="cov3" title="2">return strings.Join(items, "."), nil</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("can't convert expression %T to string", expr)</span>
}

func (e *Engine) buildString(parts []hclsyntax.Expression) (strings.Builder, error) <span class="cov1" title="1">{
        var builder strings.Builder
        for _, part := range parts </span><span class="cov0" title="0">{
                s, err := e.expToString(part)
                if err != nil </span><span class="cov0" title="0">{
                        return strings.Builder{}, err
                }</span>
                <span class="cov0" title="0">builder.WriteString(s)</span>
        }
        <span class="cov1" title="1">return builder, nil</span>
}

func (e *Engine) walkConstantItem(item hclsyntax.ObjectConsItem, walkHistory []build.PathItem) error <span class="cov3" title="2">{
        k, err := e.expToString(item.KeyExpr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="2">walkHistory = append(walkHistory, build.PathItem{Type: build.PathTypeDefault, Name: k})

        v, err := e.expToString(item.ValueExpr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="2">e.checkComment(item.ValueExpr.Range(), walkHistory, &amp;v)

        return nil</span>
}

func (e *Engine) checkComment(rg hcl.Range, walkHistory []build.PathItem, actualValue *string) <span class="cov9" title="8">{
        leadComment, endLineComment := e.commentParser.ParseCommentsForNode(rg)
        if !leadComment.IsEmpty() </span><span class="cov1" title="1">{
                e.addRule(walkHistory, leadComment, actualValue)
        }</span>
        <span class="cov9" title="8">if !endLineComment.IsEmpty() </span><span class="cov1" title="1">{
                e.addRule(walkHistory, endLineComment, actualValue)
        }</span>
}

func (e *Engine) addRule(walkHistory []build.PathItem, comment commentParser.Comment, actualValue *string) <span class="cov3" title="2">{
        tags, err := tagParser.Parse(comment.Value(), model.AllIssueTypesAsString)
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err).Msgf("Line %d: failed to parse comment '%s'", comment.Line(), comment.Value())
                return
        }</span>

        <span class="cov3" title="2">if len(tags) == 0 </span><span class="cov1" title="1">{
                return
        }</span>

        <span class="cov1" title="1">cp := make([]build.PathItem, len(walkHistory))
        copy(cp, walkHistory)

        for _, t := range tags </span><span class="cov1" title="1">{
                e.conditions = append(e.conditions, build.Condition{
                        Line:       comment.Line(),
                        IssueType:  model.IssueType(t.Name),
                        Path:       cp,
                        Value:      actualValue,
                        Attributes: t.Attributes,
                })
        }</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package model

import "github.com/Checkmarx/kics/pkg/model"

// PathItemType represents which type of path that item belongs on json representation
type PathItemType string

// Constants for kinds of PathItemTypes
const (
        PathTypeDefault      PathItemType = "DEFAULT"
        PathTypeResource     PathItemType = "RESOURCE"
        PathTypeResourceType PathItemType = "RESOURCE_TYPE"
        PathTypeResourceName PathItemType = "RESOURCE_NAME"
)

// PathItem represents json's element name and type
type PathItem struct {
        Name string
        Type PathItemType
}

// Condition represents a condition from a rule that should be checked
type Condition struct {
        Line int

        IssueType  model.IssueType
        Path       []PathItem
        Value      interface{}
        Attributes map[string]interface{}
}

// Rule represents a list of conditions to validate a rule
type Rule struct {
        Conditions []Condition
}

// Attr add some configurations to the condition to return the condition to be matched
func (c Condition) Attr(name string) (interface{}, bool) <span class="cov6" title="2">{
        v, ok := c.Attributes[name]
        if !ok </span><span class="cov1" title="1">{
                return nil, false
        }</span>

        <span class="cov1" title="1">return v, true</span>
}

// AttrAsString gets Attr and converts to string
func (c Condition) AttrAsString(name string) (string, bool) <span class="cov10" title="3">{
        v, ok := c.Attributes[name]
        if !ok </span><span class="cov1" title="1">{
                return "", false
        }</span>

        <span class="cov6" title="2">if vv, ok := v.(string); ok </span><span class="cov1" title="1">{
                return vv, true
        }</span>

        <span class="cov1" title="1">return "", false</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package tag

import (
        "bytes"
        "errors"
        "fmt"
        "strconv"
        "strings"
        "text/scanner"
)

// Tag contains the tag name reference and its atributtes
type Tag struct {
        Name       string
        Attributes map[string]interface{}
}

// Parse tag from following structure
// name1:"expected=private,test=false" name2:"attr=1"
func Parse(s string, supportedNames []string) ([]Tag, error) <span class="cov7" title="15">{
        s = strings.TrimLeft(strings.TrimLeft(strings.TrimSpace(s), "/"), " ")
        var tags []Tag
        for _, si := range strings.Split(s, " ") </span><span class="cov7" title="18">{
                cleanSi := strings.TrimSpace(si)
                if cleanSi == "" </span><span class="cov1" title="1">{
                        continue</span>
                }

                <span class="cov7" title="17">for _, supportedName := range supportedNames </span><span class="cov8" title="22">{
                        if !strings.HasPrefix(cleanSi, supportedName) </span><span class="cov5" title="6">{
                                continue</span>
                        }

                        <span class="cov7" title="16">tag, err := parseTag(cleanSi, supportedName)
                        if err != nil </span><span class="cov5" title="6">{
                                return nil, err
                        }</span>

                        <span class="cov6" title="10">tags = append(tags, tag)</span>
                }
        }

        <span class="cov6" title="9">return tags, nil</span>
}

func parseTag(s, name string) (Tag, error) <span class="cov7" title="16">{
        t := Tag{
                Name:       name,
                Attributes: make(map[string]interface{}),
        }

        attributePart := strings.TrimPrefix(s, name)
        attributePart = strings.TrimPrefix(attributePart, ":")
        attributePart = strings.TrimPrefix(attributePart, "\"")
        attributePart = strings.TrimSuffix(attributePart, "\"")

        if attributePart == "" </span><span class="cov4" title="4">{
                return t, nil
        }</span>

        <span class="cov6" title="12">sc := &amp;scanner.Scanner{}
        sc.Mode = scanner.ScanIdents | scanner.ScanInts | scanner.ScanFloats | scanner.ScanStrings
        sc.Init(strings.NewReader(attributePart))

        for </span><span class="cov10" title="43">{
                tok := sc.Scan()
                switch tok </span>{
                case scanner.EOF:<span class="cov5" title="6">
                        return t, nil</span>
                case scanner.Ident:<span class="cov8" title="26">
                        ident := sc.TokenText()
                        switch sc.Peek() </span>{
                        case '=':<span class="cov8" title="19">
                                sc.Next()
                                value, err := parseValue(sc)
                                if err != nil </span><span class="cov4" title="4">{
                                        return Tag{}, err
                                }</span>
                                <span class="cov7" title="15">t.Attributes[ident] = value</span>
                        case '[':<span class="cov2" title="2">
                                sc.Next()
                                arg, err := parseArgs(sc)
                                if err != nil </span><span class="cov1" title="1">{
                                        return Tag{}, err
                                }</span>
                                <span class="cov1" title="1">t.Attributes[ident] = arg</span>
                        case ',':<span class="cov4" title="5">
                                sc.Next()
                                t.Attributes[ident] = nil</span>
                        case scanner.EOF:<span class="cov0" title="0">
                                t.Attributes[ident] = nil</span>
                        }
                case ',':<span class="cov6" title="10"></span>
                        // NOP
                default:<span class="cov1" title="1">
                        return Tag{}, fmt.Errorf("invalid token: %s", sc.TokenText())</span>
                }
        }
}

func parseArray(sc *scanner.Scanner) ([]interface{}, error) <span class="cov4" title="4">{
        var result []interface{}
        for </span><span class="cov7" title="13">{
                value, err := parseValue(sc)
                if err != nil </span><span class="cov0" title="0">{
                        return result, err
                }</span>
                <span class="cov7" title="13">result = append(result, value)
                next := sc.Next()
                if next == ']' </span><span class="cov3" title="3">{
                        return result, nil
                }</span>
                <span class="cov6" title="10">if next == ',' </span><span class="cov6" title="9">{
                        continue</span>
                }
                <span class="cov1" title="1">return result, fmt.Errorf(", expected but got %s", string(next))</span>
        }
}

func parseValue(sc *scanner.Scanner) (interface{}, error) <span class="cov9" title="34">{
        switch sc.Peek() </span>{
        case '\'':<span class="cov7" title="18">
                sc.Next()
                return parseString(sc)</span>
        case '*':<span class="cov1" title="1">
                r := sc.Next()
                return string(r), nil</span>
        case '&lt;', '&gt;':<span class="cov2" title="2">
                r := sc.Next()
                if sc.Peek() == '=' </span><span class="cov1" title="1">{
                        sc.Next()
                        return string(r) + "=", nil
                }</span>
                <span class="cov1" title="1">return string(r), nil</span>
        case '!':<span class="cov2" title="2">
                sc.Next()
                if sc.Peek() == '=' </span><span class="cov1" title="1">{
                        sc.Next()
                        return "!=", nil
                }</span>
                <span class="cov1" title="1">return nil, fmt.Errorf("invalid value: %s", sc.TokenText())</span>
        case '[':<span class="cov4" title="4">
                sc.Next()
                return parseArray(sc)</span>
        default:<span class="cov5" title="7">
                tok := sc.Scan()
                switch tok </span>{
                case scanner.Ident:<span class="cov4" title="5">
                        return checkType(sc.TokenText()), nil</span>
                case scanner.String, scanner.Int, scanner.Float:<span class="cov2" title="2">
                        if tok == scanner.String </span><span class="cov0" title="0">{
                                str := sc.TokenText()
                                return str[1 : len(str)-1], nil
                        }</span> else<span class="cov2" title="2"> if tok == scanner.Int </span><span class="cov1" title="1">{
                                return strconv.ParseInt(sc.TokenText(), 10, 64)
                        }</span> else<span class="cov1" title="1"> if tok == scanner.Float </span><span class="cov1" title="1">{
                                return strconv.ParseFloat(sc.TokenText(), 64)
                        }</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("invalid value: %s", sc.TokenText())</span>
                }
        }
        <span class="cov0" title="0">return nil, errors.New("invalid value")</span>
}

func parseArgs(sc *scanner.Scanner) (map[string]interface{}, error) <span class="cov2" title="2">{
        result := map[string]interface{}{}
        for </span><span class="cov3" title="3">{
                tok := sc.Scan()
                if tok != scanner.Ident </span><span class="cov0" title="0">{
                        return result, fmt.Errorf("invalid attribute name: %s", sc.TokenText())
                }</span>
                <span class="cov3" title="3">name := sc.TokenText()
                eq := sc.Next()
                if eq != '=' </span><span class="cov1" title="1">{
                        return result, fmt.Errorf("= expected but got %s", string(eq))
                }</span>
                <span class="cov2" title="2">value, err := parseValue(sc)
                if err != nil </span><span class="cov0" title="0">{
                        return result, err
                }</span>
                <span class="cov2" title="2">result[name] = value
                next := sc.Next()
                if next == ']' </span><span class="cov1" title="1">{
                        return result, nil
                }</span>
                <span class="cov1" title="1">if next == ',' </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov0" title="0">return result, fmt.Errorf(") or , expected but got %s", string(next))</span>
        }
}

func parseString(sc *scanner.Scanner) (string, error) <span class="cov7" title="18">{
        var buf bytes.Buffer
        ch := sc.Next()
        for ch != '\'' </span><span class="cov8" title="26">{
                if ch == '\n' || ch == '\r' || ch &lt; 0 </span><span class="cov1" title="1">{
                        return "", errors.New("unterminated string")
                }</span>
                <span class="cov8" title="25">if ch == '\\' </span><span class="cov6" title="12">{
                        s, err := parseEscape(sc)
                        if err != nil </span><span class="cov1" title="1">{
                                return "", err
                        }</span>
                        <span class="cov6" title="11">buf.WriteString(s)</span>
                } else<span class="cov7" title="13"> {
                        buf.WriteRune(ch)
                }</span>
                <span class="cov8" title="24">ch = sc.Next()</span>
        }
        <span class="cov7" title="16">return buf.String(), nil</span>
}

func parseEscape(sc *scanner.Scanner) (string, error) <span class="cov6" title="12">{
        ch := sc.Next()
        switch ch </span>{
        case 'a':<span class="cov1" title="1">
                return "\a", nil</span>
        case 'b':<span class="cov1" title="1">
                return "\b", nil</span>
        case 'f':<span class="cov1" title="1">
                return "\f", nil</span>
        case 'n':<span class="cov1" title="1">
                return "\n", nil</span>
        case 'r':<span class="cov1" title="1">
                return "\r", nil</span>
        case 't':<span class="cov1" title="1">
                return "\t", nil</span>
        case 'v':<span class="cov1" title="1">
                return "\v", nil</span>
        case '\\':<span class="cov1" title="1">
                return "\\", nil</span>
        case '"':<span class="cov2" title="2">
                return "\"", nil</span>
        case '\'':<span class="cov1" title="1">
                return "'", nil</span>
        }
        <span class="cov1" title="1">return "", fmt.Errorf("invalid escape sequence: %s", string(ch))</span>
}

func checkType(s string) interface{} <span class="cov4" title="5">{
        switch s </span>{
        case "true", "TRUE":<span class="cov1" title="1">
                return true</span>
        case "false", "FALSE":<span class="cov1" title="1">
                return false</span>
        default:<span class="cov3" title="3">
                if i, err := strconv.ParseInt(s, 10, 64); err == nil </span><span class="cov0" title="0">{
                        return i
                }</span>
                <span class="cov3" title="3">if f, err := strconv.ParseFloat(s, 64); err == nil </span><span class="cov0" title="0">{
                        return f
                }</span>

                <span class="cov3" title="3">return s</span>
        }
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package writer

import (
        "bytes"
        "fmt"
        "html/template"
        "strconv"
        "strings"

        build "github.com/Checkmarx/kics/pkg/builder/model"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
)

// RegoWriter represents the template for a Rego rule
type RegoWriter struct {
        tmpl *template.Template
}

// Block represents a json block of a file for scan
type Block struct {
        Name string
        All  bool
        List []string
}

// RegoRule contains a block to be scanned and a rule to be applied
type RegoRule struct {
        Block Block
        build.Rule
}

const (
        stringValue = "\"%s\""
)

// NewRegoWriter initializes a default RegoWriter using builder template
func NewRegoWriter() (*RegoWriter, error) <span class="cov1" title="1">{
        tmpl, err := template.New("template.gorego").
                Funcs(template.FuncMap{
                        "condition": condition,
                        "regoValue": regoValueToString,
                        "lastCondition": func(r RegoRule) build.Condition </span><span class="cov1" title="1">{
                                return r.Conditions[len(r.Conditions)-1]
                        }</span>,
                        "unescape": func(v string) template.HTML <span class="cov1" title="1">{
                                return template.HTML(v) // nolint:gosec
                        }</span>,
                        "innerKey": func(r RegoRule) template.HTML <span class="cov2" title="2">{
                                condition := r.Conditions[len(r.Conditions)-1]
                                return template.HTML(conditionKey(r.Block, condition, false, true)) // nolint:gosec
                        }</span>,
                        "searchKey": func(r RegoRule) template.HTML <span class="cov1" title="1">{
                                format := "%%s[%%s].%s"
                                condition := r.Conditions[len(r.Conditions)-1]
                                var vars []string

                                if v, ok := condition.Attr("resource"); ok &amp;&amp; v == "*" </span><span class="cov1" title="1">{
                                        vars = append(vars, "blockType")
                                }</span> else<span class="cov0" title="0"> {
                                        vars = append(vars, "blockTypes[blockIndex]")
                                }</span>
                                <span class="cov1" title="1">vars = append(vars, "name")
                                if _, ok := condition.Attr("any_key"); ok </span><span class="cov1" title="1">{
                                        format += ".%%s"
                                        vars = append(vars, "key")
                                }</span>
                                <span class="cov1" title="1">format = fmt.Sprintf(format, conditionKey(r.Block, condition, false, true))

                                return template.HTML(fmt.Sprintf("sprintf(\"%s\", [%s])", format, strings.Join(vars, ", ")))</span> // nolint:gosec
                        },
                }).
                ParseFiles("./pkg/builder/writer/template.gorego")
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return &amp;RegoWriter{tmpl: tmpl}, nil</span>
}

// Render starts RegoWriter rules list passed as parameter
func (w *RegoWriter) Render(rules []build.Rule) ([]byte, error) <span class="cov1" title="1">{
        wr := bytes.NewBuffer(nil)

        if err := w.tmpl.Execute(wr, format(rules)); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to render")
        }</span>

        <span class="cov1" title="1">return wr.Bytes(), nil</span>
}

func condition(r Block, c build.Condition) string <span class="cov5" title="6">{
        key := conditionKey(r, c, true, false)

        if c.IssueType == model.IssueTypeRedundantAttribute </span><span class="cov1" title="1">{
                return key
        }</span>
        <span class="cov4" title="5">if c.IssueType == model.IssueTypeMissingAttribute </span><span class="cov1" title="1">{
                return fmt.Sprintf("not %s", key)
        }</span>

        <span class="cov4" title="4">if _, ok := c.Attr("upper"); ok </span><span class="cov1" title="1">{
                key = fmt.Sprintf("upper(%s)", key)
        }</span>
        <span class="cov4" title="4">if _, ok := c.Attr("lower"); ok </span><span class="cov1" title="1">{
                key = fmt.Sprintf("lower(%s)", key)
        }</span>

        <span class="cov4" title="4">if reg, ok := c.Attr("regex"); ok </span><span class="cov1" title="1">{
                return fmt.Sprintf("re_match(\"%s\", %s)", reg, key)
        }</span>

        <span class="cov3" title="3">condition := "=="
        if v, ok := c.AttrAsString("condition"); ok </span><span class="cov1" title="1">{
                condition = v
        }</span>

        <span class="cov3" title="3">if value, ok := c.AttrAsString("val"); ok </span><span class="cov1" title="1">{
                return fmt.Sprintf("%s %s %s", key, condition, regoValueToString(value))
        }</span>

        <span class="cov2" title="2">return fmt.Sprintf("%s %s %s", key, condition, regoValueToString(c.Value))</span>
}

func regoValueToString(i interface{}) string <span class="cov7" title="15">{
        switch v := i.(type) </span>{
        case bool:<span class="cov2" title="2">
                if v </span><span class="cov1" title="1">{
                        return "true"
                }</span>
                <span class="cov1" title="1">return "false"</span>
        case int64:<span class="cov1" title="1">
                return strconv.Itoa(int(v))</span>
        case int32:<span class="cov1" title="1">
                return strconv.Itoa(int(v))</span>
        case int:<span class="cov1" title="1">
                return strconv.Itoa(v)</span>
        case float64:<span class="cov1" title="1">
                return strconv.FormatFloat(v, 'f', 6, 64)</span>
        case float32:<span class="cov1" title="1">
                return strconv.FormatFloat(float64(v), 'f', 6, 32)</span>
        case string:<span class="cov4" title="4">
                return fmt.Sprintf(stringValue, v)</span>
        case *string:<span class="cov2" title="2">
                if v == nil </span><span class="cov1" title="1">{
                        return "\"\""
                }</span>
                <span class="cov1" title="1">return fmt.Sprintf(stringValue, *v)</span>
        case []string:<span class="cov1" title="1">
                sts := make([]string, 0, len(v))
                for _, vi := range v </span><span class="cov3" title="3">{
                        sts = append(sts, fmt.Sprintf(stringValue, vi))
                }</span>

                <span class="cov1" title="1">return fmt.Sprintf("{%s}", strings.Join(sts, ", "))</span>
        default:<span class="cov1" title="1">
                log.Warn().Msgf("Can't convert value, %T to string", i)
                return ""</span>
        }
}

func conditionKey(block Block, c build.Condition, withBlockPrefix, pathOnly bool) string <span class="cov6" title="10">{
        key := ""
        if withBlockPrefix </span><span class="cov5" title="7">{
                key = "block"
        }</span>
        <span class="cov6" title="10">for i, pathItem := range c.Path </span><span class="cov10" title="50">{
                switch pathItem.Type </span>{
                case build.PathTypeResourceType:<span class="cov6" title="10">
                        if pathOnly </span><span class="cov3" title="3">{
                                continue</span>
                        } else<span class="cov5" title="7"> if block.All </span><span class="cov5" title="7">{
                                key += "[blockType]"
                        }</span> else<span class="cov0" title="0"> {
                                key += "[blockTypes[blockIndex]]"
                        }</span>
                case build.PathTypeResourceName:<span class="cov6" title="10">
                        if !pathOnly </span><span class="cov5" title="7">{
                                key += "[name]"
                        }</span>
                case build.PathTypeDefault:<span class="cov7" title="20">
                        key = buildDefaultType(c, i, pathOnly, pathItem, key)</span>
                }
        }

        <span class="cov6" title="10">return key</span>
}

func buildDefaultType(c build.Condition, i int, pathOnly bool, pathItem build.PathItem, key string) string <span class="cov7" title="20">{
        if _, ok := c.Attr("any_key"); ok &amp;&amp; i == len(c.Path)-1 </span><span class="cov6" title="10">{
                if !pathOnly </span><span class="cov5" title="7">{
                        key += "[key]"
                }</span>
                <span class="cov6" title="10">return key</span>
        }

        <span class="cov6" title="10">if key != "" </span><span class="cov5" title="7">{
                key += "."
        }</span>

        <span class="cov6" title="10">key += pathItem.Name
        return key</span>
}

func format(rules []build.Rule) []RegoRule <span class="cov2" title="2">{
        res := make([]RegoRule, len(rules))
        for i, r := range rules </span><span class="cov2" title="2">{
                res[i] = RegoRule{
                        Rule:  r,
                        Block: createBlock(r),
                }
        }</span>

        <span class="cov2" title="2">return res</span>
}

func createBlock(rule build.Rule) Block <span class="cov3" title="3">{ // nolint:gocyclo
        result := Block{}
        result = resultName(rule, result)

        resources := make(map[string]struct{}, len(rule.Conditions))
        for _, condition := range rule.Conditions </span><span class="cov3" title="3">{
                if len(condition.Path) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov3" title="3">v, ok := condition.Attr("resource")
                if !ok </span><span class="cov0" title="0">{
                        for _, pathItem := range condition.Path </span><span class="cov0" title="0">{
                                if pathItem.Type == build.PathTypeResourceType </span><span class="cov0" title="0">{
                                        resources[pathItem.Name] = struct{}{}
                                }</span>
                        }

                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov3" title="3">resources, result = switchFunction(v, result, resources)</span>
        }

        <span class="cov3" title="3">result.List = make([]string, 0, len(resources))
        for resource := range resources </span><span class="cov3" title="3">{
                result.List = append(result.List, resource)
        }</span>

        <span class="cov3" title="3">return result</span>
}

func switchFunction(v interface{}, result Block, resources map[string]struct{}) (map[string]struct{}, Block) <span class="cov4" title="5">{
        switch vv := v.(type) </span>{
        case string:<span class="cov4" title="4">
                if vv == "*" </span><span class="cov4" title="4">{
                        result.All = true
                }</span>
                <span class="cov4" title="4">resources[vv] = struct{}{}</span>
        case []string:<span class="cov1" title="1">
                for _, vi := range vv </span><span class="cov2" title="2">{
                        resources[vi] = struct{}{}
                }</span>
        case []interface{}:<span class="cov0" title="0">
                for _, vi := range vv </span><span class="cov0" title="0">{
                        if vvi, ok := vi.(string); ok </span><span class="cov0" title="0">{
                                resources[vvi] = struct{}{}
                        }</span>
                }
        }
        <span class="cov4" title="5">return resources, result</span>
}

func resultName(rule build.Rule, result Block) Block <span class="cov4" title="4">{
        for _, pathItem := range rule.Conditions[len(rule.Conditions)-1].Path </span><span class="cov4" title="4">{
                if pathItem.Type == build.PathTypeResource </span><span class="cov4" title="4">{
                        result.Name = pathItem.Name
                        break</span>
                }
        }
        <span class="cov4" title="4">return result</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package detector

import (
        "strconv"
        "strings"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/rs/zerolog"
)

const (
        undetectedVulnerabilityLine = -1
)

type defaultDetectLine struct {
}

// DetectLine searches vulnerability line if kindDetectLine is not in detectors
func (d defaultDetectLine) DetectLine(file *model.FileMetadata, searchKey string,
        logWithFields *zerolog.Logger, outputLines int) model.VulnerabilityLines <span class="cov7" title="3">{
        text := strings.ReplaceAll(file.OriginalData, "\r", "")
        lines := strings.Split(text, "\n")
        var isBreak bool
        foundAtLeastOne := false
        currentLine := 0
        var extractedString [][]string
        extractedString = GetBracketValues(searchKey, extractedString, "")
        sanitizedSubstring := searchKey
        for idx, str := range extractedString </span><span class="cov7" title="3">{
                sanitizedSubstring = strings.Replace(sanitizedSubstring, str[0], `{{`+strconv.Itoa(idx)+`}}`, -1)
        }</span>

        <span class="cov7" title="3">for _, key := range strings.Split(sanitizedSubstring, ".") </span><span class="cov10" title="5">{
                substr1, substr2 := GenerateSubstrings(key, extractedString)

                foundAtLeastOne, currentLine, isBreak = DetectCurrentLine(lines, substr1, substr2, currentLine, foundAtLeastOne)

                if isBreak </span><span class="cov1" title="1">{
                        break</span>
                }
        }

        <span class="cov7" title="3">if foundAtLeastOne </span><span class="cov4" title="2">{
                return model.VulnerabilityLines{
                        Line:      currentLine + 1,
                        VulnLines: GetAdjacentVulnLines(currentLine, outputLines, lines),
                }
        }</span>

        <span class="cov1" title="1">logWithFields.Warn().Msgf("Failed to detect line, query response %s", searchKey)

        return model.VulnerabilityLines{
                Line:      undetectedVulnerabilityLine,
                VulnLines: []model.CodeLine{},
        }</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package detector

import (
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/rs/zerolog"
)

type kindDetectLine interface {
        DetectLine(file *model.FileMetadata, searchKey string,
                logWithFields *zerolog.Logger, outputLines int) model.VulnerabilityLines
}

// DetectLine is a struct that associates a kindDetectLine to its FileKind
type DetectLine struct {
        detectors       map[model.FileKind]kindDetectLine
        outputLines     int
        logWithFields   *zerolog.Logger
        defaultDetector kindDetectLine
}

// NewDetectLine creates a new DetectLine's reference
func NewDetectLine(outputLines int) *DetectLine <span class="cov10" title="6">{
        return &amp;DetectLine{
                detectors:       make(map[model.FileKind]kindDetectLine),
                logWithFields:   &amp;zerolog.Logger{},
                outputLines:     outputLines,
                defaultDetector: defaultDetectLine{},
        }
}</span>

// SetupLogs will change the logger feild to be used in kindDetectLine DetectLine method
func (d *DetectLine) SetupLogs(logger *zerolog.Logger) <span class="cov1" title="1">{
        d.logWithFields = logger
}</span>

// Add adds a new kindDetectLine to the caller and returns it
func (d *DetectLine) Add(detector kindDetectLine, kind model.FileKind) *DetectLine <span class="cov4" title="2">{
        d.detectors[kind] = detector
        return d
}</span>

// DetectLine will use the correct kindDetectLine according to the files kind
// if file kind is not in detectors default detect line is called
func (d *DetectLine) DetectLine(file *model.FileMetadata, searchKey string) model.VulnerabilityLines <span class="cov4" title="2">{
        if det, ok := d.detectors[file.Kind]; ok </span><span class="cov1" title="1">{
                return det.DetectLine(file, searchKey, d.logWithFields, d.outputLines)
        }</span>
        <span class="cov1" title="1">return d.defaultDetector.DetectLine(file, searchKey, d.logWithFields, d.outputLines)</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package docker

import (
        "regexp"
        "strconv"
        "strings"

        "github.com/Checkmarx/kics/pkg/detector"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/rs/zerolog"
)

// DetectKindLine defines a kindDetectLine type
type DetectKindLine struct {
}

const (
        undetectedVulnerabilityLine = -1
)

var (
        nameRegexDockerFileML = regexp.MustCompile(`.+\s+\\$`)
)

// DetectLine searches vulnerability line in docker files
func (d DetectKindLine) DetectLine(file *model.FileMetadata, searchKey string,
        logWithFields *zerolog.Logger, outputLines int) model.VulnerabilityLines <span class="cov3" title="3">{
        text := strings.ReplaceAll(file.OriginalData, "\r", "")
        lines := prepareDockerFileLines(text)
        var isBreak bool
        foundAtLeastOne := false
        currentLine := 0
        var extractedString [][]string
        extractedString = detector.GetBracketValues(searchKey, extractedString, "")
        sKey := searchKey
        for idx, str := range extractedString </span><span class="cov4" title="5">{
                sKey = strings.Replace(sKey, str[0], `{{`+strconv.Itoa(idx)+`}}`, -1)
        }</span>

        <span class="cov3" title="3">for _, key := range strings.Split(sKey, ".") </span><span class="cov5" title="6">{
                substr1, substr2 := detector.GenerateSubstrings(key, extractedString)

                foundAtLeastOne, currentLine, isBreak = detector.DetectCurrentLine(lines, substr1, substr2,
                        currentLine, foundAtLeastOne)

                if isBreak </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov3" title="3">if foundAtLeastOne </span><span class="cov3" title="3">{
                return model.VulnerabilityLines{
                        Line:      currentLine + 1,
                        VulnLines: detector.GetAdjacentVulnLines(currentLine, outputLines, strings.Split(text, "\n")),
                }
        }</span>

        <span class="cov0" title="0">logWithFields.Warn().Msgf("Failed to detect Docker line, query response %s", searchKey)

        return model.VulnerabilityLines{
                Line:      undetectedVulnerabilityLine,
                VulnLines: []model.CodeLine{},
        }</span>
}

func prepareDockerFileLines(text string) []string <span class="cov3" title="3">{
        textSplit := strings.Split(text, "\n")
        for idx, key := range textSplit </span><span class="cov9" title="37">{
                textSplit[idx] = multiLineSpliter(textSplit, key, idx)
        }</span>
        <span class="cov3" title="3">return textSplit</span>
}

func multiLineSpliter(textSplit []string, key string, idx int) string <span class="cov10" title="48">{
        if nameRegexDockerFileML.MatchString(key) </span><span class="cov6" title="11">{
                i := idx + 1
                for textSplit[i] == "" </span><span class="cov5" title="8">{
                        i++
                }</span>
                <span class="cov6" title="11">textSplit[idx] = strings.ReplaceAll(textSplit[idx], " \\", " "+textSplit[i])
                textSplit[i] = ""
                textSplit[idx] = multiLineSpliter(textSplit, textSplit[idx], idx)</span>
        }
        <span class="cov10" title="48">return textSplit[idx]</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package helm

import (
        "fmt"
        "sort"
        "strconv"
        "strings"

        "github.com/Checkmarx/kics/pkg/detector"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/agnivade/levenshtein"
        "github.com/rs/zerolog"
)

// DetectKindLine defines a kindDetectLine type
type DetectKindLine struct {
}

type detectCurlLine struct {
        foundRes   bool
        lineRes    int
        breakRes   bool
        lastUnique dupHistory
}

// dupHistory keeps the history of uniques
type dupHistory struct {
        unique         bool
        lastUniqueLine int
}

const (
        undetectedVulnerabilityLine = -1
)

// DetectLine is used to detect line on the helm template,
// it looks only at the keys of the template and will make use of the auxiliary added
// lines (ex: "# KICS_HELM_ID_")
func (d DetectKindLine) DetectLine(file *model.FileMetadata, searchKey string,
        logWithFields *zerolog.Logger, outputLines int) model.VulnerabilityLines <span class="cov2" title="3">{
        searchKey = fmt.Sprintf("%s.%s", strings.TrimRight(strings.TrimLeft(file.HelmID, "# "), ":"), searchKey)
        text := strings.ReplaceAll(file.OriginalData, "\r", "")
        lines := strings.Split(text, "\n")
        curLineRes := detectCurlLine{
                foundRes: false,
                lineRes:  0,
                breakRes: false,
        }
        var extractedString [][]string
        extractedString = detector.GetBracketValues(searchKey, extractedString, "")
        sanitizedSubstring := searchKey
        for idx, str := range extractedString </span><span class="cov3" title="6">{
                sanitizedSubstring = strings.Replace(sanitizedSubstring, str[0], `{{`+strconv.Itoa(idx)+`}}`, -1)
        }</span>

        <span class="cov2" title="3">helmID, err := strconv.Atoi(strings.TrimSuffix(strings.TrimPrefix(file.HelmID, "# KICS_HELM_ID_"), ":"))
        if err != nil </span><span class="cov0" title="0">{
                helmID = -1
        }</span>

        // Since we are only looking at keys we can ignore the second value passed through '=' and '[]'
        <span class="cov2" title="3">for _, key := range strings.Split(sanitizedSubstring, ".") </span><span class="cov5" title="18">{
                substr1, _ := detector.GenerateSubstrings(key, extractedString)
                curLineRes = curLineRes.detectCurrentLine(lines, fmt.Sprintf("%s:", substr1), "", true, file.IDInfo, helmID)

                if curLineRes.breakRes </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        // Look at dupHistory to see if the last element was duplicate, if so
        // change the line to the last unique key
        <span class="cov2" title="3">if !curLineRes.lastUnique.unique </span><span class="cov1" title="1">{
                curLineRes.lineRes = curLineRes.lastUnique.lastUniqueLine
        }</span>

        <span class="cov2" title="3">if curLineRes.foundRes </span><span class="cov2" title="3">{
                lineRemove := make(map[int]int)
                count := 0
                for i, line := range lines </span><span class="cov7" title="74">{ // Remove auxiliary lines
                        if strings.Contains(line, "# KICS_HELM_ID_") </span><span class="cov3" title="4">{
                                count++
                                lineRemove[i] = count
                                lines = append(lines[:i], lines[i+1:]...)
                        }</span>
                }
                // Update found line
                <span class="cov2" title="3">curLineRes.lineRes = removeLines(curLineRes.lineRes, lineRemove)
                return model.VulnerabilityLines{
                        Line:                 curLineRes.lineRes + 1,
                        VulnLines:            detector.GetAdjacentVulnLines(curLineRes.lineRes, outputLines, lines),
                        LineWithVulnerabilty: strings.Split(lines[curLineRes.lineRes], ": ")[0],
                }</span>
        }

        <span class="cov0" title="0">logWithFields.Warn().Msgf("Failed to detect line, query response %s", searchKey)

        return model.VulnerabilityLines{
                Line:      undetectedVulnerabilityLine,
                VulnLines: []model.CodeLine{},
        }</span>
}

// removeLines is used to update the vulnerability line after removing the "# KICS_HELM_ID_"
func removeLines(current int, lineRemove map[int]int) int <span class="cov2" title="3">{
        orderByKey := make([]int, len(lineRemove))
        i := 0
        for k := range lineRemove </span><span class="cov3" title="4">{
                orderByKey[i] = k
                i++
        }</span>
        <span class="cov2" title="3">remove := 0
        sort.Ints(orderByKey)
        for _, k := range orderByKey </span><span class="cov3" title="4">{
                if current &gt; k </span><span class="cov3" title="4">{
                        remove = lineRemove[k]
                }</span> else<span class="cov0" title="0"> {
                        break</span>
                }
        }
        <span class="cov2" title="3">current -= remove
        return current</span>
}

func (d detectCurlLine) detectCurrentLine(lines []string, str1,
        str2 string, byKey bool, idInfo map[int]interface{}, id int) detectCurlLine <span class="cov5" title="18">{
        distances := make(map[int]int)
        for i := d.lineRes; i &lt; len(lines); i++ </span><span class="cov10" title="311">{
                if str1 != "" &amp;&amp; str2 != "" </span><span class="cov0" title="0">{
                        if strings.Contains(lines[i], str1) &amp;&amp; strings.Contains(lines[i], str2) </span><span class="cov0" title="0">{
                                distances[i] = levenshtein.ComputeDistance(detector.ExtractLineFragment(lines[i], str2, byKey), str2)
                        }</span>
                } else<span class="cov10" title="311"> if str1 != "" </span><span class="cov10" title="311">{
                        if strings.Contains(lines[i], str1) </span><span class="cov5" title="23">{
                                distances[i] = levenshtein.ComputeDistance(
                                        detector.ExtractLineFragment(strings.TrimSpace(lines[i]), str1, byKey), str1)
                        }</span>
                }
        }

        <span class="cov5" title="18">lastSingle := d.lastUnique.lastUniqueLine

        if len(distances) == 0 </span><span class="cov0" title="0">{
                return detectCurlLine{
                        foundRes: d.foundRes,
                        lineRes:  d.lineRes,
                        breakRes: true,
                        lastUnique: dupHistory{
                                lastUniqueLine: lastSingle,
                                unique:         d.lastUnique.unique,
                        },
                }
        }</span>

        <span class="cov5" title="18">lineResponse := detector.SelectLineWithMinimumDistance(distances, d.lineRes)
        // if lineResponse is unique
        unique := detectLastSingle(lineResponse, distances, idInfo, id)
        if unique </span><span class="cov5" title="17">{
                lastSingle = lineResponse
        }</span>

        <span class="cov5" title="18">return detectCurlLine{
                foundRes: true,
                lineRes:  lineResponse,
                breakRes: false,
                lastUnique: dupHistory{
                        unique:         unique,
                        lastUniqueLine: lastSingle,
                },
        }</span>
}

// detectLastSingle checks if the line is unique or a duplicate
func detectLastSingle(line int, dis map[int]int, idInfo map[int]interface{}, id int) bool <span class="cov5" title="18">{
        if idInfo == nil </span><span class="cov4" title="12">{
                return true
        }</span>
        <span class="cov3" title="6">for key, value := range dis </span><span class="cov4" title="9">{
                if value == dis[line] &amp;&amp; key != line </span><span class="cov1" title="1">{
                        // check if we are only looking at original data equivalent to the vulnerability
                        if ok := idInfo[id].(map[int]int)[key]; ok != 0 </span><span class="cov1" title="1">{
                                return false
                        }</span>
                }
        }
        <span class="cov3" title="5">return true</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package detector

import (
        "fmt"
        "regexp"
        "strconv"
        "strings"

        "github.com/Checkmarx/kics/internal/constants"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/agnivade/levenshtein"
)

var (
        nameRegex       = regexp.MustCompile(`^([A-Za-z0-9-_]+)\[([A-Za-z0-9-_{}]+)]$`)
        nameRegexDocker = regexp.MustCompile(`{{(.*?)}}`)
)

const (
        namePartsLength  = 3
        valuePartsLength = 2
)

// GetBracketValues gets values inside "{{ }}" ignoring any "{{" or "}}" inside
func GetBracketValues(expr string, list [][]string, restOfString string) [][]string <span class="cov7" title="15">{
        var tempList []string
        firstOpen := strings.Index(expr, "{{")
        firstClose := strings.Index(expr, "}}")
        switchVal := firstClose - firstOpen
        if switchVal == 0 </span><span class="cov5" title="8">{ // if there is no "{{" and no "}}"
                if expr != "" </span><span class="cov5" title="6">{
                        tempList = append(tempList, fmt.Sprintf("{{%s}}", expr), expr)
                        list = append(list, tempList)
                }</span>
                <span class="cov5" title="8">if restOfString == "" </span><span class="cov5" title="7">{
                        return list // if there is no more string to read from return value of list
                }</span>
                <span class="cov1" title="1">list = GetBracketValues(restOfString, list, "")</span> // recursive call to the rest of the string
        } else<span class="cov5" title="7"> if switchVal &gt; 0 </span><span class="cov4" title="5">{ // if the position of  the first "}}" is bigger than than the position of "{{"
                // recursive with the value inside of curly brackets
                list = GetBracketValues(expr[firstOpen+2:firstClose], list, expr[firstClose+2:])
        }</span> else<span class="cov2" title="2"> { // if the position of  the first "{{" is bigger than than the position of "}}"
                nextClose := strings.Index(restOfString, "}}")
                tempList = append(tempList, fmt.Sprintf("{{%s%s}}", expr, restOfString[nextClose:]),
                        fmt.Sprintf("%s%s", expr, restOfString[nextClose:]))
                list = append(list, tempList)
                list = GetBracketValues(restOfString[nextClose+2:], list, "") // recursive call to the rest of the string
        }</span>
        <span class="cov5" title="8">return list</span>
}

// GenerateSubstrings returns the substrings used for line searching depending on search key
// '.' is new line
// '=' is value in the same line
// '[]' is in the same line
func GenerateSubstrings(key string, extractedString [][]string) (substr1Res, substr2Res string) <span class="cov4" title="5">{
        var substr1, substr2 string
        if parts := nameRegex.FindStringSubmatch(key); len(parts) == namePartsLength </span><span class="cov2" title="2">{
                substr1, substr2 = getKeyWithCurlyBrackets(key, extractedString, parts)
        }</span> else<span class="cov3" title="3"> if parts := strings.Split(key, "="); len(parts) == valuePartsLength </span><span class="cov1" title="1">{
                substr1, substr2 = getKeyWithCurlyBrackets(key, extractedString, parts)
        }</span> else<span class="cov2" title="2"> {
                parts := []string{key, ""}
                substr1, substr2 = getKeyWithCurlyBrackets(key, extractedString, parts)
        }</span>
        <span class="cov4" title="5">return substr1, substr2</span>
}

func getKeyWithCurlyBrackets(key string, extractedString [][]string, parts []string) (substr1Res, substr2Res string) <span class="cov4" title="5">{
        var substr1, substr2 string
        extractedPart := nameRegexDocker.FindStringSubmatch(key)
        if len(extractedPart) == valuePartsLength </span><span class="cov1" title="1">{
                for idx, key := range parts </span><span class="cov2" title="2">{
                        if extractedPart[0] == key </span><span class="cov1" title="1">{
                                switch idx </span>{
                                case (len(parts) - 2):<span class="cov0" title="0">
                                        i, _ := strconv.Atoi(extractedPart[1])
                                        substr1 = extractedString[i][1]</span>
                                case len(parts) - 1:<span class="cov1" title="1">
                                        i, _ := strconv.Atoi(extractedPart[1])
                                        substr2 = extractedString[i][1]</span>
                                }
                        } else<span class="cov1" title="1"> {
                                substr1 = generateSubstr(substr1, parts, 2)
                                substr2 = generateSubstr(substr2, parts, 1)
                        }</span>
                }
        } else<span class="cov4" title="4"> {
                substr1 = parts[len(parts)-2]
                substr2 = parts[len(parts)-1]
        }</span>

        <span class="cov4" title="5">return substr1, substr2</span>
}

func generateSubstr(substr string, parts []string, leng int) string <span class="cov2" title="2">{
        if substr == "" </span><span class="cov2" title="2">{
                substr = parts[len(parts)-leng]
        }</span>
        <span class="cov2" title="2">return substr</span>
}

// GetAdjacentVulnLines is used to get the lines adjecent to the line that contains the vulnerability
// adj is the amount of lines wanted
func GetAdjacentVulnLines(idx, adj int, lines []string) []model.CodeLine <span class="cov5" title="9">{
        var endPos int
        var startPos int
        if adj &lt;= len(lines) </span><span class="cov5" title="8">{
                endPos = idx + adj/2 + 1 // if adj lines passes the number of lines in file
                if len(lines) &lt; endPos </span><span class="cov1" title="1">{
                        endPos = len(lines)
                }</span>
                <span class="cov5" title="8">startAdj := adj
                if adj%2 == 0 </span><span class="cov2" title="2">{
                        startAdj--
                }</span>

                <span class="cov5" title="8">startPos = idx - startAdj/2 // if adj lines passes the first line in the file
                if startPos &lt; 0 </span><span class="cov1" title="1">{
                        startPos = 0
                }</span>
        } else<span class="cov1" title="1"> { // in case adj is bigger than number of lines in file
                adj = len(lines)
                endPos = len(lines)
                startPos = 0
        }</span>

        <span class="cov5" title="9">switch idx </span>{
        case 0:<span class="cov2" title="2">
                // case vulnerability is the first line of the file
                return createVulnLines(1, lines[:adj])</span>
        case len(lines) - 1:<span class="cov3" title="3">
                // case vulnerability is the last line of the file
                return createVulnLines(startPos+1, lines[len(lines)-adj:])</span>
        default:<span class="cov4" title="4">
                // case vulnerability is in the midle of the file
                return createVulnLines(startPos+1, lines[startPos:endPos])</span>
        }
}

// createVulnLines is the function that will  generate the array that contains the lines numbers
// used to alter the color of the line that contains the vulnerability
func createVulnLines(startPos int, lines []string) []model.CodeLine <span class="cov5" title="9">{
        vulns := make([]model.CodeLine, len(lines))
        for idx, line := range lines </span><span class="cov8" title="24">{
                vulns[idx] = model.CodeLine{
                        Line:     line,
                        Position: startPos,
                }
                startPos++
        }</span>
        <span class="cov5" title="9">return vulns</span>
}

// SelectLineWithMinimumDistance will search a map of levenshtein distances to find the minimum distance
func SelectLineWithMinimumDistance(distances map[int]int, startingFrom int) int <span class="cov5" title="7">{
        minDistance, lineOfMinDistance := constants.MaxInteger, startingFrom
        for line, distance := range distances </span><span class="cov6" title="10">{
                if distance &lt; minDistance || distance == minDistance &amp;&amp; line &lt; lineOfMinDistance </span><span class="cov5" title="7">{
                        minDistance = distance
                        lineOfMinDistance = line
                }</span>
        }

        <span class="cov5" title="7">return lineOfMinDistance</span>
}

// ExtractLineFragment will prepare substr for line detection
func ExtractLineFragment(line, substr string, key bool) string <span class="cov4" title="4">{
        // If detecting line by keys only
        if key </span><span class="cov0" title="0">{
                return line[:strings.Index(line, ":")]
        }</span>
        <span class="cov4" title="4">start := strings.Index(line, substr)
        end := start + len(substr)

        for start &gt;= 0 </span><span class="cov8" title="30">{
                if line[start] == ' ' </span><span class="cov3" title="3">{
                        break</span>
                }

                <span class="cov8" title="27">start--</span>
        }

        <span class="cov4" title="4">for end &lt; len(line) </span><span class="cov7" title="16">{
                if line[end] == ' ' </span><span class="cov3" title="3">{
                        break</span>
                }

                <span class="cov6" title="13">end++</span>
        }

        <span class="cov4" title="4">return removeExtras(line, start, end)</span>
}

func removeExtras(result string, start, end int) string <span class="cov4" title="4">{
        // workaround for selecting yaml keys
        if result[end-1] == ':' </span><span class="cov0" title="0">{
                end--
        }</span>

        <span class="cov4" title="4">if result[end-1] == '"' </span><span class="cov3" title="3">{
                end--
        }</span>

        <span class="cov4" title="4">if result[start+1] == '"' </span><span class="cov3" title="3">{
                start++
        }</span>

        <span class="cov4" title="4">return result[start+1 : end]</span>
}

// DetectCurrentLine uses levenshtein distance to find the most acurate line for the vulnerability
func DetectCurrentLine(lines []string, str1, str2 string,
        curLine int, foundOne bool) (foundRes bool, lineRes int, breakRes bool) <span class="cov4" title="5">{
        distances := make(map[int]int)
        for i := curLine; i &lt; len(lines); i++ </span><span class="cov10" title="53">{
                if str1 != "" &amp;&amp; str2 != "" </span><span class="cov8" title="32">{
                        if strings.Contains(lines[i], str1) &amp;&amp; strings.Contains(lines[i], str2) </span><span class="cov3" title="3">{
                                distances[i] = levenshtein.ComputeDistance(ExtractLineFragment(lines[i], str2, false), str2)
                        }</span>
                } else<span class="cov7" title="21"> if str1 != "" </span><span class="cov7" title="21">{
                        if strings.Contains(lines[i], str1) </span><span class="cov1" title="1">{
                                distances[i] = levenshtein.ComputeDistance(ExtractLineFragment(lines[i], str1, false), str1)
                        }</span>
                }
        }

        <span class="cov4" title="5">if len(distances) == 0 </span><span class="cov1" title="1">{
                return foundOne, curLine, true
        }</span>

        <span class="cov4" title="4">return true, SelectLineWithMinimumDistance(distances, curLine), false</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package engine

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "sync"
        "time"

        consoleHelpers "github.com/Checkmarx/kics/internal/console/helpers"
        "github.com/Checkmarx/kics/pkg/detector"
        "github.com/Checkmarx/kics/pkg/detector/docker"
        "github.com/Checkmarx/kics/pkg/detector/helm"
        "github.com/Checkmarx/kics/pkg/engine/source"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/getsentry/sentry-go"
        "github.com/open-policy-agent/opa/ast"
        "github.com/open-policy-agent/opa/cover"
        "github.com/open-policy-agent/opa/rego"
        "github.com/open-policy-agent/opa/topdown"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
)

// Default values for inspector
const (
        UndetectedVulnerabilityLine = -1
        DefaultQueryID              = "Undefined"
        DefaultQueryName            = "Anonymous"
        DefaultQueryDescription     = "Undefined"
        DefaultQueryURI             = "https://github.com/Checkmarx/kics/"
        DefaultIssueType            = model.IssueTypeIncorrectValue

        regoQuery      = `result = data.Cx.CxPolicy`
        executeTimeout = 60 * time.Second
)

// ErrNoResult - error representing when a query didn't return a result
var ErrNoResult = errors.New("query: not result")

// ErrInvalidResult - error representing invalid result
var ErrInvalidResult = errors.New("query: invalid result format")

// VulnerabilityBuilder represents a function that will build a vulnerability
type VulnerabilityBuilder func(ctx *QueryContext, tracker Tracker, v interface{},
        detector *detector.DetectLine) (model.Vulnerability, error)

// Tracker wraps an interface that contain basic methods: TrackQueryLoad, TrackQueryExecution and FailedDetectLine
// TrackQueryLoad increments the number of loaded queries
// TrackQueryExecution increments the number of queries executed
// FailedDetectLine decrements the number of queries executed
// GetOutputLines returns the number of lines to be displayed in results outputs
type Tracker interface {
        TrackQueryLoad(queryAggregation int)
        TrackQueryExecution(queryAggregation int)
        FailedDetectLine()
        FailedComputeSimilarityID()
        GetOutputLines() int
}

type preparedQuery struct {
        opaQuery rego.PreparedEvalQuery
        metadata model.QueryMetadata
}

// Inspector represents a list of compiled queries, a builder for vulnerabilities, an information tracker
// a flag to enable coverage and the coverage report if it is enabled
type Inspector struct {
        queries        []*preparedQuery
        vb             VulnerabilityBuilder
        tracker        Tracker
        failedQueries  map[string]error
        excludeResults map[string]bool
        detector       *detector.DetectLine

        enableCoverageReport bool
        coverageReport       cover.Report
}

// QueryContext contains the context where the query is executed, which scan it belongs, basic information of query,
// the query compiled and its payload
type QueryContext struct {
        ctx          context.Context
        scanID       string
        files        map[string]model.FileMetadata
        query        *preparedQuery
        payload      model.Documents
        baseScanPath string
}

var (
        unsafeRegoFunctions = map[string]struct{}{
                "http.send":   {},
                "opa.runtime": {},
        }
)

// NewInspector initializes a inspector, compiling and loading queries for scan and its tracker
func NewInspector(
        ctx context.Context,
        queriesSource source.QueriesSource,
        vb VulnerabilityBuilder,
        tracker Tracker,
        excludeQueries source.ExcludeQueries,
        excludeResults map[string]bool) (*Inspector, error) <span class="cov1" title="1">{
        log.Debug().Msg("engine.NewInspector()")

        queries, err := queriesSource.GetQueries(excludeQueries)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to get queries")
        }</span>

        <span class="cov1" title="1">commonGeneralQuery, err := queriesSource.GetQueryLibrary("common")
        if err != nil </span><span class="cov0" title="0">{
                sentry.CaptureException(err)
                log.Err(err).
                        Msgf("Inspector failed to get general query, query=%s", "common")
        }</span>
        <span class="cov1" title="1">opaQueries := make([]*preparedQuery, 0, len(queries))
        for _, metadata := range queries </span><span class="cov1" title="1">{
                platformGeneralQuery, err := queriesSource.GetQueryLibrary(metadata.Platform)
                if err != nil </span><span class="cov0" title="0">{
                        sentry.CaptureException(err)
                        log.Err(err).
                                Msgf("Inspector failed to get generic query, query=%s", metadata.Query)

                        continue</span>
                }

                <span class="cov1" title="1">select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, nil</span>
                default:<span class="cov1" title="1">
                        opaQuery, err := rego.New(
                                rego.Query(regoQuery),
                                rego.Module("Common", commonGeneralQuery),
                                rego.Module("Generic", platformGeneralQuery),
                                rego.Module(metadata.Query, metadata.Content),
                                rego.UnsafeBuiltins(unsafeRegoFunctions),
                        ).PrepareForEval(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                sentry.CaptureException(err)
                                log.Err(err).
                                        Msgf("Inspector failed to prepare query for evaluation, query=%s", metadata.Query)

                                continue</span>
                        }

                        <span class="cov1" title="1">tracker.TrackQueryLoad(metadata.Aggregation)

                        opaQueries = append(opaQueries, &amp;preparedQuery{
                                opaQuery: opaQuery,
                                metadata: metadata,
                        })</span>
                }
        }
        <span class="cov1" title="1">failedQueries := make(map[string]error)

        queriesNumber := sumAllAggregatedQueries(opaQueries)

        log.Info().
                Msgf("Inspector initialized, number of queries=%d", queriesNumber)

        lineDetctor := detector.NewDetectLine(tracker.GetOutputLines()).
                Add(helm.DetectKindLine{}, model.KindHELM).
                Add(docker.DetectKindLine{}, model.KindDOCKER)

        return &amp;Inspector{
                queries:        opaQueries,
                vb:             vb,
                tracker:        tracker,
                failedQueries:  failedQueries,
                excludeResults: excludeResults,
                detector:       lineDetctor,
        }, nil</span>
}

func sumAllAggregatedQueries(opaQueries []*preparedQuery) int <span class="cov1" title="1">{
        sum := 0
        for _, query := range opaQueries </span><span class="cov1" title="1">{
                sum += query.metadata.Aggregation
        }</span>
        <span class="cov1" title="1">return sum</span>
}

func startProgressBar(hideProgress bool, total int, wg *sync.WaitGroup, progressChannel chan float64) <span class="cov10" title="2">{
        wg.Add(1)
        progressBar := consoleHelpers.NewProgressBar("Executing queries: ", 10, float64(total), progressChannel)
        if hideProgress </span><span class="cov10" title="2">{
                progressBar.Writer = io.Discard
        }</span>
        <span class="cov10" title="2">go progressBar.Start(wg)</span>
}

// Inspect scan files and return the a list of vulnerabilities found on the process
func (c *Inspector) Inspect(
        ctx context.Context,
        scanID string,
        files model.FileMetadatas,
        hideProgress bool,
        baseScanPath string) ([]model.Vulnerability, error) <span class="cov10" title="2">{
        log.Debug().Msg("engine.Inspect()")
        combinedFiles := files.Combine()

        _, err := json.Marshal(combinedFiles)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="2">var vulnerabilities []model.Vulnerability
        vulnerabilities = make([]model.Vulnerability, 0)
        currentQuery := make(chan float64, 1)
        var wg sync.WaitGroup
        startProgressBar(hideProgress, len(c.queries), &amp;wg, currentQuery)
        for idx, query := range c.queries </span><span class="cov10" title="2">{
                if !hideProgress </span><span class="cov0" title="0">{
                        currentQuery &lt;- float64(idx)
                }</span>

                <span class="cov10" title="2">vuls, err := c.doRun(&amp;QueryContext{
                        ctx:          ctx,
                        scanID:       scanID,
                        files:        files.ToMap(),
                        query:        query,
                        payload:      combinedFiles,
                        baseScanPath: baseScanPath,
                })
                if err != nil </span><span class="cov0" title="0">{
                        sentry.CaptureException(err)
                        log.Err(err).
                                Str("scanID", scanID).
                                Msgf("Inspector. query executed with error, query=%s", query.metadata.Query)

                        c.failedQueries[query.metadata.Query] = err

                        continue</span>
                }

                <span class="cov10" title="2">vulnerabilities = append(vulnerabilities, vuls...)

                c.tracker.TrackQueryExecution(query.metadata.Aggregation)</span>
        }
        <span class="cov10" title="2">close(currentQuery)
        wg.Wait()
        fmt.Println("\r")
        return vulnerabilities, nil</span>
}

// EnableCoverageReport enables the flag to create a coverage report
func (c *Inspector) EnableCoverageReport() <span class="cov1" title="1">{
        c.enableCoverageReport = true
}</span>

// GetCoverageReport returns the scan coverage report
func (c *Inspector) GetCoverageReport() cover.Report <span class="cov1" title="1">{
        return c.coverageReport
}</span>

// GetFailedQueries returns a map of failed queries and the associated error
func (c *Inspector) GetFailedQueries() map[string]error <span class="cov0" title="0">{
        return c.failedQueries
}</span>

func (c *Inspector) doRun(ctx *QueryContext) ([]model.Vulnerability, error) <span class="cov10" title="2">{
        timeoutCtx, cancel := context.WithTimeout(ctx.ctx, executeTimeout)
        defer cancel()

        options := []rego.EvalOption{rego.EvalInput(ctx.payload)}

        var cov *cover.Cover
        if c.enableCoverageReport </span><span class="cov10" title="2">{
                cov = cover.New()
                options = append(options, rego.EvalQueryTracer(cov))
        }</span>

        <span class="cov10" title="2">results, err := ctx.query.opaQuery.Eval(timeoutCtx, options...)
        if err != nil </span><span class="cov0" title="0">{
                if topdown.IsCancel(err) </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "query executing timeout exited")
                }</span>

                <span class="cov0" title="0">return nil, errors.Wrap(err, "failed to evaluate query")</span>
        }
        <span class="cov10" title="2">if c.enableCoverageReport &amp;&amp; cov != nil </span><span class="cov10" title="2">{
                module, parseErr := ast.ParseModule(ctx.query.metadata.Query, ctx.query.metadata.Content)
                if parseErr != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(parseErr, "failed to parse coverage module")
                }</span>

                <span class="cov10" title="2">c.coverageReport = cov.Report(map[string]*ast.Module{
                        ctx.query.metadata.Query: module,
                })</span>
        }

        <span class="cov10" title="2">log.Trace().
                Str("scanID", ctx.scanID).
                Msgf("Inspector executed with result %+v, query=%s", results, ctx.query.metadata.Query)

        return c.decodeQueryResults(ctx, results)</span>
}

func (c *Inspector) decodeQueryResults(ctx *QueryContext, results rego.ResultSet) ([]model.Vulnerability, error) <span class="cov10" title="2">{
        if len(results) == 0 </span><span class="cov0" title="0">{
                return nil, ErrNoResult
        }</span>

        <span class="cov10" title="2">result := results[0].Bindings

        queryResult, ok := result["result"]
        if !ok </span><span class="cov0" title="0">{
                return nil, ErrNoResult
        }</span>

        <span class="cov10" title="2">queryResultItems, ok := queryResult.([]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, ErrInvalidResult
        }</span>

        <span class="cov10" title="2">vulnerabilities := make([]model.Vulnerability, 0, len(queryResultItems))
        failedDetectLine := false
        for _, queryResultItem := range queryResultItems </span><span class="cov10" title="2">{
                vulnerability, err := c.vb(ctx, c.tracker, queryResultItem, c.detector)
                if err != nil </span><span class="cov0" title="0">{
                        sentry.CaptureException(err)
                        log.Err(err).
                                Msgf("Inspector can't save vulnerability, query=%s", ctx.query.metadata.Query)

                        if _, ok := c.failedQueries[ctx.query.metadata.Query]; !ok </span><span class="cov0" title="0">{
                                c.failedQueries[ctx.query.metadata.Query] = err
                        }</span>

                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov10" title="2">if vulnerability.Line == UndetectedVulnerabilityLine </span><span class="cov10" title="2">{
                        failedDetectLine = true
                }</span>

                <span class="cov10" title="2">if _, ok := c.excludeResults[vulnerability.SimilarityID]; ok </span><span class="cov1" title="1">{
                        log.Debug().
                                Msgf("Excluding result SimilarityID: %s", vulnerability.SimilarityID)
                }</span> else<span class="cov1" title="1"> {
                        vulnerabilities = append(vulnerabilities, vulnerability)
                }</span>
        }

        <span class="cov10" title="2">if failedDetectLine </span><span class="cov10" title="2">{
                c.tracker.FailedDetectLine()
        }</span>

        <span class="cov10" title="2">return vulnerabilities, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package provider

import (
        "context"
        "os"
        "path/filepath"
        "strings"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/getsentry/sentry-go"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
)

// FileSystemSourceProvider provides a path to be scanned
// and a list of files which will not be scanned
type FileSystemSourceProvider struct {
        path     string
        excludes map[string][]os.FileInfo
}

// ErrNotSupportedFile - error representing when a file format is not supported by KICS
var ErrNotSupportedFile = errors.New("invalid file format")

// NewFileSystemSourceProvider initializes a FileSystemSourceProvider with path and files that will be ignored
func NewFileSystemSourceProvider(path string, excludes []string) (*FileSystemSourceProvider, error) <span class="cov2" title="3">{
        log.Debug().Msgf("provider.NewFileSystemSourceProvider()")
        ex := make(map[string][]os.FileInfo, len(excludes))
        fs := &amp;FileSystemSourceProvider{
                path:     filepath.FromSlash(path),
                excludes: ex,
        }
        for _, exclude := range excludes </span><span class="cov1" title="1">{
                excludePaths, err := getExcludePaths(exclude)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov1" title="1">if err := fs.AddExcluded(excludePaths); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov2" title="3">return fs, nil</span>
}

// AddExcluded add new excluded files to the File System Source Provider
func (s *FileSystemSourceProvider) AddExcluded(excludePaths []string) error <span class="cov2" title="3">{
        for _, excludePath := range excludePaths </span><span class="cov1" title="2">{
                info, err := os.Stat(excludePath)
                if err != nil </span><span class="cov1" title="1">{
                        if os.IsNotExist(err) </span><span class="cov1" title="1">{
                                continue</span>
                        }
                        <span class="cov0" title="0">return errors.Wrap(err, "failed to open excluded file")</span>
                }
                <span class="cov1" title="1">if _, ok := s.excludes[info.Name()]; !ok </span><span class="cov1" title="1">{
                        s.excludes[info.Name()] = make([]os.FileInfo, 0)
                }</span>
                <span class="cov1" title="1">s.excludes[info.Name()] = append(s.excludes[info.Name()], info)</span>
        }
        <span class="cov2" title="3">return nil</span>
}

func getExcludePaths(pathExpressions string) ([]string, error) <span class="cov1" title="1">{
        if strings.ContainsAny(pathExpressions, "*?[") </span><span class="cov0" title="0">{
                info, err := filepath.Glob(pathExpressions)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to open excluded file")
                }</span>
                <span class="cov0" title="0">return info, nil</span>
        }
        <span class="cov1" title="1">return []string{pathExpressions}, nil</span>
}

// GetBasePath returns base path of FileSystemSourceProvider
func (s *FileSystemSourceProvider) GetBasePath() string <span class="cov1" title="1">{
        return s.path
}</span>

// GetSources tries to open file or directory and execute sink function on it
func (s *FileSystemSourceProvider) GetSources(ctx context.Context,
        extensions model.Extensions, sink Sink, resolverSink ResolverSink) error <span class="cov2" title="7">{
        resolved := false
        fileInfo, err := os.Stat(s.path)
        if err != nil </span><span class="cov2" title="3">{
                return errors.Wrap(err, "failed to open path")
        }</span>

        <span class="cov2" title="4">if !fileInfo.IsDir() </span><span class="cov1" title="1">{
                if !extensions.Include(filepath.Ext(s.path)) &amp;&amp; !extensions.Include(filepath.Base(s.path)) </span><span class="cov0" title="0">{
                        return ErrNotSupportedFile
                }</span>

                <span class="cov1" title="1">c, errOpenFile := os.Open(s.path)
                if errOpenFile != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(errOpenFile, "failed to open path")
                }</span>

                <span class="cov1" title="1">return sink(ctx, s.path, c)</span>
        }

        <span class="cov2" title="3">err = filepath.Walk(s.path, func(path string, info os.FileInfo, err error) error </span><span class="cov9" title="14867">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov9" title="14867">if shouldSkip, skipFolder := s.checkConditions(info, extensions, path, resolved); shouldSkip </span><span class="cov9" title="14636">{
                        return skipFolder
                }</span>

                // ------------------ Helm resolver --------------------------------
                <span class="cov6" title="231">if info.IsDir() </span><span class="cov1" title="1">{
                        excluded, errRes := resolverSink(ctx, strings.ReplaceAll(path, "\\", "/"))
                        if errRes != nil </span><span class="cov0" title="0">{
                                sentry.CaptureException(errRes)
                                log.Err(errRes).
                                        Msgf("Filesystem files provider couldn't Resolve Directory, file=%s", info.Name())
                                return nil
                        }</span>
                        <span class="cov1" title="1">if errAdd := s.AddExcluded(excluded); errAdd != nil </span><span class="cov0" title="0">{
                                log.Err(errAdd).Msgf("Filesystem files provider couldn't exclude rendered Chart files, Chart=%s", info.Name())
                        }</span>
                        <span class="cov1" title="1">resolved = true
                        return nil</span>
                }
                // -----------------------------------------------------------------

                <span class="cov6" title="230">c, err := os.Open(filepath.Clean(path))
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "failed to open file")
                }</span>
                <span class="cov6" title="230">defer closeFile(c, info)

                err = sink(ctx, strings.ReplaceAll(path, "\\", "/"), c)
                if err != nil </span><span class="cov5" title="115">{
                        sentry.CaptureException(err)
                        log.Err(err).
                                Msgf("Filesystem files provider couldn't parse file, file=%s", info.Name())
                }</span>
                <span class="cov6" title="230">return nil</span>
        })

        <span class="cov2" title="3">return errors.Wrap(err, "failed to walk directory")</span>
}

func closeFile(file *os.File, info os.FileInfo) <span class="cov6" title="230">{
        if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                sentry.CaptureException(err)
                log.Err(err).
                        Msgf("Filesystem couldn't close file, file=%s", info.Name())
        }</span>
}

func (s *FileSystemSourceProvider) checkConditions(info os.FileInfo, extensions model.Extensions,
        path string, resolved bool) (bool, error) <span class="cov10" title="14870">{
        if info.IsDir() </span><span class="cov8" title="3724">{
                if f, ok := s.excludes[info.Name()]; ok &amp;&amp; containsFile(f, info) </span><span class="cov1" title="1">{
                        log.Info().Msgf("Directory ignored: %s", path)
                        return true, filepath.SkipDir
                }</span>
                <span class="cov8" title="3723">_, err := os.Stat(filepath.Join(path, "Chart.yaml"))
                if err != nil || resolved </span><span class="cov8" title="3721">{
                        return true, nil
                }</span>
                <span class="cov1" title="2">return false, nil</span>
        }

        <span class="cov9" title="11146">if f, ok := s.excludes[info.Name()]; ok &amp;&amp; containsFile(f, info) </span><span class="cov0" title="0">{
                log.Info().Msgf("File ignored: %s", path)
                return true, nil
        }</span>
        <span class="cov9" title="11146">if !extensions.Include(filepath.Ext(path)) &amp;&amp; !extensions.Include(filepath.Base(path)) </span><span class="cov9" title="10916">{
                return true, nil
        }</span>
        <span class="cov6" title="230">return false, nil</span>
}

func containsFile(fileList []os.FileInfo, target os.FileInfo) bool <span class="cov1" title="1">{
        for _, file := range fileList </span><span class="cov1" title="1">{
                if os.SameFile(file, target) </span><span class="cov1" title="1">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package engine

import (
        "crypto/sha256"
        "encoding/hex"
        "path/filepath"
)

// ComputeSimilarityID This function receives four string parameters and computes a sha256 hash
func ComputeSimilarityID(basePath, filePath, queryID, searchKey, searchValue string) (*string, error) <span class="cov9" title="17">{
        standardizedPath, err := standardizeToRelativePath(basePath, filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov9" title="17">var stringNode = standardizedPath + queryID + searchKey + searchValue

        hashSum := sha256.Sum256([]byte(stringNode))

        return stringToPtrString(hex.EncodeToString(hashSum[:])), nil</span>
}

func standardizeToRelativePath(basePath, path string) (string, error) <span class="cov10" title="21">{
        cleanPath := filepath.Clean(path)
        standardPath := filepath.ToSlash(cleanPath)
        basePath = filepath.ToSlash(basePath)
        relativeStandardPath, err := filepath.Rel(basePath, standardPath)
        if err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>
        <span class="cov9" title="20">return filepath.ToSlash(relativeStandardPath), nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package source

import (
        "encoding/json"
        "os"
        "path"
        "path/filepath"
        "sort"
        "strings"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/getsentry/sentry-go"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
)

// FilesystemSource this type defines a struct with a path to a filesystem source of queries
// Source is the path to the queries
// Types are the types given by the flag --type for query selection mechanism
type FilesystemSource struct {
        Source string
        Types  []string
}

const (
        // QueryFileName The default query file name
        QueryFileName = "query.rego"
        // MetadataFileName The default metadata file name
        MetadataFileName = "metadata.json"
        // LibraryFileName The default library file name
        LibraryFileName = "library.rego"
        // LibrariesDefaultBasePath the path to rego libraries
        LibrariesDefaultBasePath = "./assets/libraries/"
)

var (
        supportedPlatforms = map[string]string{
                "Ansible":        "ansible",
                "CloudFormation": "cloudformation",
                "Dockerfile":     "dockerfile",
                "Kubernetes":     "k8s",
                "Terraform":      "terraform",
                "OpenAPI":        "openapi",
        }
)

// NewFilesystemSource initializes a NewFilesystemSource with source to queries and types of queries to load
func NewFilesystemSource(source string, types []string) *FilesystemSource <span class="cov6" title="9">{
        log.Debug().Msg("source.NewFilesystemSource()")

        if len(types) == 0 </span><span class="cov0" title="0">{
                types = []string{""}
        }</span>
        <span class="cov6" title="9">return &amp;FilesystemSource{
                Source: filepath.FromSlash(source),
                Types:  types,
        }</span>
}

// ListSupportedPlatforms returns a list of supported platforms
func ListSupportedPlatforms() []string <span class="cov1" title="1">{
        keys := make([]string, len(supportedPlatforms))
        i := 0
        for k := range supportedPlatforms </span><span class="cov5" title="6">{
                keys[i] = k
                i++
        }</span>
        <span class="cov1" title="1">sort.Strings(keys)
        return keys</span>
}

// GetPathToLibrary returns the libraries path for a given platform
func GetPathToLibrary(platform, relativeBasePath string) string <span class="cov6" title="7">{
        var libraryPath string
        if strings.LastIndex(relativeBasePath, filepath.FromSlash("/queries")) &gt; -1 </span><span class="cov6" title="7">{
                libraryPath = relativeBasePath[:strings.LastIndex(relativeBasePath, filepath.FromSlash("/queries"))] + filepath.FromSlash("/libraries")
        }</span> else<span class="cov0" title="0"> {
                libraryPath = filepath.Join(relativeBasePath, LibrariesDefaultBasePath)
        }</span>

        <span class="cov6" title="7">libraryFilePath := filepath.FromSlash(libraryPath + "/common/" + LibraryFileName)

        for _, supPlatform := range supportedPlatforms </span><span class="cov10" title="33">{
                if strings.Contains(strings.ToUpper(platform), strings.ToUpper(supPlatform)) </span><span class="cov5" title="5">{
                        libraryFilePath = filepath.FromSlash(libraryPath + "/" + supPlatform + "/" + LibraryFileName)
                        break</span>
                }
        }

        <span class="cov6" title="7">return libraryFilePath</span>
}

// GetQueryLibrary returns the library.rego for the platform passed in the argument
func (s *FilesystemSource) GetQueryLibrary(platform string) (string, error) <span class="cov6" title="7">{
        pathToLib := GetPathToLibrary(platform, s.Source)

        content, err := os.ReadFile(filepath.Clean(pathToLib))
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err).
                        Msgf("Failed to get filesystem source rego library %s", pathToLib)
        }</span>

        <span class="cov6" title="7">return string(content), err</span>
}

// CheckType checks if the queries have the type passed as an argument in '--type' flag to be loaded
func (s *FilesystemSource) CheckType(queryPlatform interface{}) bool <span class="cov1" title="1">{
        if queryPlatform.(string) == "Common" </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov1" title="1">if s.Types[0] != "" </span><span class="cov0" title="0">{
                return strings.Contains(strings.ToUpper(strings.Join(s.Types, ",")), strings.ToUpper(queryPlatform.(string)))
        }</span>
        <span class="cov1" title="1">return true</span>
}

func checkQueryExclude(id interface{}, excludeQueries []string) bool <span class="cov2" title="2">{
        queryMetadataKey, ok := id.(string)
        if !ok </span><span class="cov0" title="0">{
                log.Warn().
                        Msgf("Can't cast query metadata key = %v", id)
                return false
        }</span>
        <span class="cov2" title="2">for _, excludedQuery := range excludeQueries </span><span class="cov0" title="0">{
                if queryMetadataKey == excludedQuery </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov2" title="2">return false</span>
}

// GetQueries walks a given filesource path returns all queries found in an array of
// QueryMetadata struct
func (s *FilesystemSource) GetQueries(excludeQueries ExcludeQueries) ([]model.QueryMetadata, error) <span class="cov2" title="2">{
        queryDirs := make([]string, 0)
        err := filepath.Walk(s.Source,
                func(p string, f os.FileInfo, err error) error </span><span class="cov6" title="8">{
                        if err != nil </span><span class="cov1" title="1">{
                                return err
                        }</span>

                        <span class="cov6" title="7">if f.IsDir() || f.Name() != QueryFileName </span><span class="cov5" title="6">{
                                return nil
                        }</span>

                        <span class="cov1" title="1">queryDirs = append(queryDirs, filepath.Dir(p))
                        return nil</span>
                })
        <span class="cov2" title="2">if err != nil </span><span class="cov1" title="1">{
                return nil, errors.Wrap(err, "failed to get query Source")
        }</span>

        <span class="cov1" title="1">queries := make([]model.QueryMetadata, 0, len(queryDirs))
        for _, queryDir := range queryDirs </span><span class="cov1" title="1">{
                query, errRQ := ReadQuery(queryDir)
                if errRQ != nil </span><span class="cov0" title="0">{
                        sentry.CaptureException(errRQ)
                        log.Err(errRQ).
                                Msgf("Query provider failed to read query, query=%s", path.Base(queryDir))

                        continue</span>
                }

                <span class="cov1" title="1">if !s.CheckType(query.Metadata["platform"]) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov1" title="1">if checkQueryExclude(query.Metadata["id"], excludeQueries.ByIDs) ||
                        checkQueryExclude(query.Metadata["category"], excludeQueries.ByCategories) </span><span class="cov0" title="0">{
                        log.Debug().
                                Msgf("Excluding query ID: %s category: %s", query.Metadata["id"], query.Metadata["category"])
                        continue</span>
                }

                <span class="cov1" title="1">queries = append(queries, query)</span>
        }

        <span class="cov1" title="1">return queries, err</span>
}

// ReadQuery reads query's files for a given path and returns a QueryMetadata struct with it's
// content
func ReadQuery(queryDir string) (model.QueryMetadata, error) <span class="cov1" title="1">{
        queryContent, err := os.ReadFile(filepath.Clean(path.Join(queryDir, QueryFileName)))
        if err != nil </span><span class="cov0" title="0">{
                return model.QueryMetadata{}, errors.Wrapf(err, "failed to read query %s", path.Base(queryDir))
        }</span>

        <span class="cov1" title="1">metadata := ReadMetadata(queryDir)
        platform := getPlatform(queryDir)

        aggregation := 1
        if agg, ok := metadata["aggregation"]; ok </span><span class="cov0" title="0">{
                aggregation = int(agg.(float64))
        }</span>

        <span class="cov1" title="1">return model.QueryMetadata{
                Query:       path.Base(filepath.ToSlash(queryDir)),
                Content:     string(queryContent),
                Metadata:    metadata,
                Platform:    platform,
                Aggregation: aggregation,
        }, nil</span>
}

// ReadMetadata read query's metadata file inside the query directory
func ReadMetadata(queryDir string) map[string]interface{} <span class="cov3" title="3">{
        f, err := os.Open(filepath.Clean(path.Join(queryDir, MetadataFileName)))
        if err != nil </span><span class="cov1" title="1">{
                sentry.CaptureException(err)
                if os.IsNotExist(err) </span><span class="cov1" title="1">{
                        log.Warn().
                                Msgf("Queries provider can't find metadata, query=%s", path.Base(queryDir))

                        return nil
                }</span>

                <span class="cov0" title="0">log.Err(err).
                        Msgf("Queries provider can't read metadata, query=%s", path.Base(queryDir))

                return nil</span>
        }
        <span class="cov2" title="2">defer func() </span><span class="cov2" title="2">{
                if err := f.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Err(err).
                                Msgf("Queries provider can't close file, file=%s", filepath.Clean(path.Join(queryDir, MetadataFileName)))
                }</span>
        }()

        <span class="cov2" title="2">var metadata map[string]interface{}
        if err := json.NewDecoder(f).Decode(&amp;metadata); err != nil </span><span class="cov0" title="0">{
                sentry.CaptureException(err)
                log.Err(err).
                        Msgf("Queries provider can't unmarshal metadata, query=%s", path.Base(queryDir))

                return nil
        }</span>

        <span class="cov2" title="2">return metadata</span>
}

func getPlatform(queryPath string) string <span class="cov6" title="8">{
        if strings.Contains(queryPath, "common") </span><span class="cov1" title="1">{
                return "common"
        }</span> else<span class="cov6" title="7"> if strings.Contains(queryPath, "ansible") </span><span class="cov1" title="1">{
                return "ansible"
        }</span> else<span class="cov5" title="6"> if strings.Contains(queryPath, "cloudFormation") </span><span class="cov1" title="1">{
                return "cloudFormation"
        }</span> else<span class="cov5" title="5"> if strings.Contains(queryPath, "dockerfile") </span><span class="cov1" title="1">{
                return "dockerfile"
        }</span> else<span class="cov4" title="4"> if strings.Contains(queryPath, "k8s") </span><span class="cov1" title="1">{
                return "k8s"
        }</span> else<span class="cov3" title="3"> if strings.Contains(queryPath, "terraform") </span><span class="cov1" title="1">{
                return "terraform"
        }</span> else<span class="cov2" title="2"> if strings.Contains(queryPath, "openAPI") </span><span class="cov1" title="1">{
                return "openAPI"
        }</span>

        <span class="cov1" title="1">return "unknown"</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package engine

import (
        "encoding/json"
        "fmt"
        "strconv"
        "strings"

        "github.com/Checkmarx/kics/pkg/detector"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/pkg/errors"
        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
)

func getStringFromMap(vulnParam, defaultParam string, vOjb map[string]interface{}, logWithFields *zerolog.Logger) string <span class="cov7" title="18">{
        ts, err := mapKeyToString(vOjb, vulnParam, false)
        if err != nil </span><span class="cov7" title="18">{
                logWithFields.Err(err).
                        Msgf("Saving result. failed to detect %s", vulnParam)
                return defaultParam
        }</span>
        <span class="cov0" title="0">return *ts</span>
}

// DefaultVulnerabilityBuilder defines a vulnerability builder to execute default actions of scan
var DefaultVulnerabilityBuilder = func(ctx *QueryContext, tracker Tracker,
        v interface{}, detector *detector.DetectLine) (model.Vulnerability, error) <span class="cov3" title="3">{
        vObj, ok := v.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return model.Vulnerability{}, ErrInvalidResult
        }</span>

        <span class="cov3" title="3">vObj = mergeWithMetadata(vObj, ctx.query.metadata.Metadata)

        var err error
        var output []byte

        output, err = json.Marshal(vObj)
        if err != nil </span><span class="cov0" title="0">{
                return model.Vulnerability{}, errors.Wrap(err, "failed to marshall query output")
        }</span>

        <span class="cov3" title="3">var fileID *string

        fileID, err = mapKeyToString(vObj, "documentId", false)
        if err != nil </span><span class="cov0" title="0">{
                return model.Vulnerability{}, errors.Wrap(err, "failed to recognize file id")
        }</span>

        <span class="cov3" title="3">file, ok := ctx.files[*fileID]
        if !ok </span><span class="cov0" title="0">{
                return model.Vulnerability{}, errors.New("failed to find file from query response")
        }</span>

        <span class="cov3" title="3">logWithFields := log.With().
                Str("scanID", ctx.scanID).
                Str("fileName", file.FileName).
                Str("queryName", ctx.query.metadata.Query).
                Logger()

        detector.SetupLogs(&amp;logWithFields)

        linesVulne := model.VulnerabilityLines{
                Line:      -1,
                VulnLines: []model.CodeLine{},
        }

        searchKey := ""
        if s, ok := vObj["searchKey"]; ok </span><span class="cov3" title="3">{
                searchKey = s.(string)
                linesVulne = detector.DetectLine(&amp;file, searchKey)
        }</span> else<span class="cov0" title="0"> {
                logWithFields.Error().Msg("Saving result. failed to detect line")
        }</span>

        <span class="cov3" title="3">searchValue := ""
        if s, ok := vObj["searchValue"]; ok </span><span class="cov0" title="0">{
                searchValue = s.(string)
        }</span>

        <span class="cov3" title="3">queryID := getStringFromMap("id", DefaultQueryID, vObj, &amp;logWithFields)

        var severity model.Severity = model.SeverityInfo
        var s *string

        if s, err = mapKeyToString(vObj, "severity", false); err == nil </span><span class="cov1" title="1">{
                su := strings.ToUpper(*s)
                var found bool
                for _, si := range model.AllSeverities </span><span class="cov4" title="4">{
                        if su == string(si) </span><span class="cov1" title="1">{
                                severity = si
                                found = true
                                break</span>
                        }
                }

                <span class="cov1" title="1">if !found </span><span class="cov0" title="0">{
                        logWithFields.Warn().Str("severity", *s).Msg("Saving result. invalid severity constant value")
                }</span>
        } else<span class="cov2" title="2"> {
                logWithFields.Info().Msg("Saving result. failed to detect severity")
        }</span>

        <span class="cov3" title="3">issueType := DefaultIssueType
        if v := mustMapKeyToString(vObj, "issueType"); v != nil </span><span class="cov3" title="3">{
                issueType = model.IssueType(*v)
        }</span>

        <span class="cov3" title="3">var similarityID *string

        similarityID, err = ComputeSimilarityID(ctx.baseScanPath, file.FileName, queryID, searchKey, searchValue)
        if err != nil </span><span class="cov0" title="0">{
                logWithFields.Err(err).Send()
                tracker.FailedComputeSimilarityID()
        }</span>

        <span class="cov3" title="3">return model.Vulnerability{
                ID:               0,
                SimilarityID:     ptrStringToString(similarityID),
                ScanID:           ctx.scanID,
                FileID:           file.ID,
                FileName:         file.FileName,
                QueryName:        getStringFromMap("queryName", DefaultQueryName, vObj, &amp;logWithFields),
                QueryID:          queryID,
                QueryURI:         getStringFromMap("descriptionUrl", DefaultQueryURI, vObj, &amp;logWithFields),
                Category:         getStringFromMap("category", "", vObj, &amp;logWithFields),
                Description:      getStringFromMap("descriptionText", "", vObj, &amp;logWithFields),
                Severity:         severity,
                Platform:         getStringFromMap("platform", "", vObj, &amp;logWithFields),
                Line:             linesVulne.Line,
                VulnLines:        linesVulne.VulnLines,
                IssueType:        issueType,
                SearchKey:        searchKey,
                SearchValue:      searchValue,
                KeyExpectedValue: ptrStringToString(mustMapKeyToString(vObj, "keyExpectedValue")),
                KeyActualValue:   ptrStringToString(mustMapKeyToString(vObj, "keyActualValue")),
                Value:            mustMapKeyToString(vObj, "value"),
                Output:           string(output),
        }, nil</span>
}

func mergeWithMetadata(base, additional map[string]interface{}) map[string]interface{} <span class="cov4" title="5">{
        for k, v := range additional </span><span class="cov5" title="6">{
                if _, ok := base[k]; ok </span><span class="cov1" title="1">{
                        continue</span>
                }

                <span class="cov4" title="5">base[k] = v</span>
        }

        <span class="cov4" title="5">return base</span>
}

func mustMapKeyToString(m map[string]interface{}, key string) *string <span class="cov6" title="13">{
        res, err := mapKeyToString(m, key, true)
        if err != nil &amp;&amp; key != "value" </span><span class="cov2" title="2">{
                log.Warn().
                        Str("reason", err.Error()).
                        Msgf("Failed to get key %s in map", key)
        }</span>

        <span class="cov6" title="13">return res</span>
}

func mapKeyToString(m map[string]interface{}, key string, allowNil bool) (*string, error) <span class="cov10" title="47">{
        v, ok := m[key]
        if !ok </span><span class="cov8" title="30">{
                return nil, fmt.Errorf("key '%s' not found in map", key)
        }</span>

        <span class="cov7" title="17">switch vv := v.(type) </span>{
        case json.Number:<span class="cov0" title="0">
                return stringToPtrString(vv.String()), nil</span>
        case string:<span class="cov6" title="12">
                return stringToPtrString(vv), nil</span>
        case int, int32, int64:<span class="cov2" title="2">
                return stringToPtrString(fmt.Sprintf("%d", vv)), nil</span>
        case float32:<span class="cov0" title="0">
                return stringToPtrString(strconv.FormatFloat(float64(vv), 'f', -1, 64)), nil</span>
        case float64:<span class="cov1" title="1">
                return stringToPtrString(strconv.FormatFloat(vv, 'f', -1, 64)), nil</span>
        case nil:<span class="cov1" title="1">
                if allowNil </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov1" title="1">return stringToPtrString("null"), nil</span>
        case bool:<span class="cov1" title="1">
                return stringToPtrString(fmt.Sprintf("%v", vv)), nil</span>
        }

        <span class="cov0" title="0">log.Debug().
                Msg("Detecting line. can't format item to string")

        if allowNil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">return stringToPtrString(""), nil</span>
}

func stringToPtrString(v string) *string <span class="cov9" title="34">{
        return &amp;v
}</span>

func ptrStringToString(v *string) string <span class="cov6" title="11">{
        if v == nil </span><span class="cov3" title="3">{
                return ""
        }</span>
        <span class="cov5" title="8">return *v</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package kics

import (
        "context"
        "encoding/json"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/getsentry/sentry-go"
        "github.com/google/uuid"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
)

func (s *Service) resolverSink(ctx context.Context, filename, scanID string) ([]string, error) <span class="cov8" title="1">{
        kind := s.Resolver.GetType(filename)
        if kind == model.KindCOMMON </span><span class="cov0" title="0">{
                return []string{}, nil
        }</span>
        <span class="cov8" title="1">resFiles, err := s.Resolver.Resolve(filename, kind)
        if err != nil </span><span class="cov0" title="0">{
                return []string{}, errors.Wrap(err, "failed to render file content")
        }</span>

        <span class="cov8" title="1">excluded := make([]string, len(resFiles.File))

        for idx, rfile := range resFiles.File </span><span class="cov8" title="1">{
                s.Tracker.TrackFileFound()
                excluded[idx] = rfile.FileName
                documents, _, err := s.Parser.Parse(rfile.FileName, rfile.Content)
                if err != nil </span><span class="cov0" title="0">{
                        return []string{}, errors.Wrap(err, "failed to parse file content")
                }</span>
                <span class="cov8" title="1">for _, document := range documents </span><span class="cov8" title="1">{
                        _, err = json.Marshal(document)
                        if err != nil </span><span class="cov0" title="0">{
                                sentry.CaptureException(err)
                                log.Err(err).Msgf("failed to marshal content in file: %s", rfile.FileName)
                                continue</span>
                        }

                        <span class="cov8" title="1">file := model.FileMetadata{
                                ID:           uuid.New().String(),
                                ScanID:       scanID,
                                Document:     document,
                                OriginalData: string(rfile.OriginalData),
                                Kind:         kind,
                                FileName:     rfile.FileName,
                                Content:      string(rfile.Content),
                                HelmID:       rfile.SplitID,
                                IDInfo:       rfile.IDInfo,
                        }
                        s.saveToFile(ctx, &amp;file)</span>
                }
                <span class="cov8" title="1">s.Tracker.TrackFileParse()</span>
        }
        <span class="cov8" title="1">return excluded, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package kics

import (
        "context"
        "io"

        "github.com/Checkmarx/kics/pkg/engine"
        "github.com/Checkmarx/kics/pkg/engine/provider"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/Checkmarx/kics/pkg/parser"
        "github.com/Checkmarx/kics/pkg/resolver"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
)

// Storage is the interface that wraps following basic methods: SaveFile, SaveVulnerability, GetVulnerability and GetScanSummary
// SaveFile should append metadata to a file
// SaveVulnerabilities should append vulnerabilities list to current storage
// GetVulnerabilities should returns all vulnerabilities associated to a scan ID
// GetScanSummary should return a list of summaries based on their scan IDs
type Storage interface {
        SaveFile(ctx context.Context, metadata *model.FileMetadata) error
        SaveVulnerabilities(ctx context.Context, vulnerabilities []model.Vulnerability) error
        GetVulnerabilities(ctx context.Context, scanID string) ([]model.Vulnerability, error)
        GetScanSummary(ctx context.Context, scanIDs []string) ([]model.SeveritySummary, error)
}

// Tracker is the interface that wraps the basic methods: TrackFileFound and TrackFileParse
// TrackFileFound should increment the number of files to be scanned
// TrackFileParse should increment the number of files parsed successfully to be scanned
type Tracker interface {
        TrackFileFound()
        TrackFileParse()
}

// Service is a struct that contains a SourceProvider to receive sources, a storage to save and retrieve scanning informations
// a parser to parse and provide files in format that KICS understand, a inspector that runs the scanning and a tracker to
// update scanning numbers
type Service struct {
        SourceProvider provider.SourceProvider
        Storage        Storage
        Parser         *parser.Parser
        Inspector      *engine.Inspector
        Tracker        Tracker
        Resolver       *resolver.Resolver
        files          model.FileMetadatas
}

// StartScan executes scan over the context, using the scanID as reference
func (s *Service) StartScan(ctx context.Context, scanID string, hideProgress bool) error <span class="cov1" title="1">{
        log.Debug().Msg("service.StartScan()")
        if err := s.SourceProvider.GetSources(
                ctx,
                s.Parser.SupportedExtensions(),
                func(ctx context.Context, filename string, rc io.ReadCloser) error </span><span class="cov5" title="2">{
                        return s.sink(ctx, filename, scanID, rc)
                }</span>,
                func(ctx context.Context, filename string) ([]string, error) <span class="cov1" title="1">{ // Sink used for resolver files and templates
                        return s.resolverSink(ctx, filename, scanID)
                }</span>,
        ); err != nil <span class="cov0" title="0">{
                return errors.Wrap(err, "failed to read sources")
        }</span>

        <span class="cov1" title="1">vulnerabilities, err := s.Inspector.Inspect(ctx, scanID, s.files, hideProgress, s.SourceProvider.GetBasePath())
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to inspect files")
        }</span>

        <span class="cov1" title="1">err = s.Storage.SaveVulnerabilities(ctx, vulnerabilities)

        return errors.Wrap(err, "failed to save vulnerabilities")</span>
}

/*
   getContent will read the passed file 1MB at a time
   to prevent resource exhaustion and return its content
*/
func getContent(rc io.Reader) (*[]byte, error) <span class="cov5" title="2">{
        maxSizeMB := 5 // Max size of file in MBs
        var content []byte
        data := make([]byte, 1048576)
        for </span><span class="cov10" title="4">{
                if maxSizeMB &lt; 0 </span><span class="cov0" title="0">{
                        return &amp;[]byte{}, errors.New("file size limit exceeded")
                }</span>
                <span class="cov10" title="4">data = data[:cap(data)]
                n, err := rc.Read(data)
                if err != nil </span><span class="cov5" title="2">{
                        if err == io.EOF </span><span class="cov5" title="2">{
                                break</span>
                        }
                        <span class="cov0" title="0">return &amp;[]byte{}, err</span>
                }
                <span class="cov5" title="2">content = append(content, data[:n]...)
                maxSizeMB--</span>
        }
        <span class="cov5" title="2">return &amp;content, nil</span>
}

// GetVulnerabilities returns a list of scan detected vulnerabilities
func (s *Service) GetVulnerabilities(ctx context.Context, scanID string) ([]model.Vulnerability, error) <span class="cov1" title="1">{
        return s.Storage.GetVulnerabilities(ctx, scanID)
}</span>

// GetScanSummary returns how many vulnerabilities of each severity was found
func (s *Service) GetScanSummary(ctx context.Context, scanIDs []string) ([]model.SeveritySummary, error) <span class="cov1" title="1">{
        return s.Storage.GetScanSummary(ctx, scanIDs)
}</span>

func (s *Service) saveToFile(ctx context.Context, file *model.FileMetadata) <span class="cov8" title="3">{
        err := s.Storage.SaveFile(ctx, file)
        if err == nil </span><span class="cov8" title="3">{
                s.files = append(s.files, *file)
        }</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package kics

import (
        "context"
        "encoding/json"
        "io"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/getsentry/sentry-go"
        "github.com/google/uuid"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
)

func (s *Service) sink(ctx context.Context, filename, scanID string, rc io.Reader) error <span class="cov10" title="2">{
        s.Tracker.TrackFileFound()

        content, err := getContent(rc)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "failed to get file content: %s", filename)
        }</span>

        <span class="cov10" title="2">if err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "failed to resolve file content: %s", filename)
        }</span>

        <span class="cov10" title="2">documents, kind, err := s.Parser.Parse(filename, *content)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to parse file content")
        }</span>
        <span class="cov10" title="2">for _, document := range documents </span><span class="cov10" title="2">{
                _, err = json.Marshal(document)
                if err != nil </span><span class="cov0" title="0">{
                        sentry.CaptureException(err)
                        log.Err(err).Msgf("failed to marshal content in file: %s", filename)
                        continue</span>
                }

                <span class="cov10" title="2">file := model.FileMetadata{
                        ID:           uuid.New().String(),
                        ScanID:       scanID,
                        Document:     document,
                        OriginalData: string(*content),
                        Kind:         kind,
                        FileName:     filename,
                }
                s.saveToFile(ctx, &amp;file)</span>
        }
        <span class="cov10" title="2">s.Tracker.TrackFileParse()

        return errors.Wrap(err, "failed to save file content")</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">// Package model (go:generate go run -mod=mod github.com/mailru/easyjson/easyjson ./$GOFILE)
package model

import (
        "sort"
        "strings"

        _ "github.com/mailru/easyjson/gen" //nolint
)

// Constants to describe what kind of file refers
const (
        KindTerraform FileKind = "TF"
        KindJSON      FileKind = "JSON"
        KindYAML      FileKind = "YAML"
        KindDOCKER    FileKind = "DOCKERFILE"
        KindCOMMON    FileKind = "*"
        KindHELM      FileKind = "HELM"
)

// Constants to describe vulnerability's severity
const (
        SeverityHigh   = "HIGH"
        SeverityMedium = "MEDIUM"
        SeverityLow    = "LOW"
        SeverityInfo   = "INFO"
)

// Constants to describe issue's type
const (
        IssueTypeMissingAttribute   IssueType = "MissingAttribute"
        IssueTypeRedundantAttribute IssueType = "RedundantAttribute"
        IssueTypeIncorrectValue     IssueType = "IncorrectValue"
)

// Arrays to group all constants of one type
var (
        AllSeverities = []Severity{
                SeverityHigh,
                SeverityMedium,
                SeverityLow,
                SeverityInfo,
        }

        AllIssueTypesAsString = []string{
                string(IssueTypeMissingAttribute),
                string(IssueTypeRedundantAttribute),
                string(IssueTypeIncorrectValue),
        }
)

// VulnerabilityLines is the representation of the found line for issue
type VulnerabilityLines struct {
        Line                 int
        VulnLines            []CodeLine
        LineWithVulnerabilty string
}

// FileKind is the extension of a file
type FileKind string

// Severity of the vulnerability
type Severity string

// IssueType is the issue's type string representation
type IssueType string

// CodeLine is the lines containing and adjecent to the vulnerability line with their respective positions
type CodeLine struct {
        Position int
        Line     string
}

// FileMetadata is a representation of basic information and content of a file
type FileMetadata struct {
        ID           string `db:"id"`
        ScanID       string `db:"scan_id"`
        Document     Document
        OriginalData string   `db:"orig_data"`
        Kind         FileKind `db:"kind"`
        FileName     string   `db:"file_name"`
        Content      string
        HelmID       string
        IDInfo       map[int]interface{}
}

// QueryMetadata is a representation of general information about a query
type QueryMetadata struct {
        Query    string
        Content  string
        Metadata map[string]interface{}
        Platform string
        // special field for generic queries
        // represents how many queries are aggregated into a single rego file
        Aggregation int
}

// Vulnerability is a representation of a detected vulnerability in scanned files
// after running a query
type Vulnerability struct {
        ID               int        `json:"id"`
        ScanID           string     `db:"scan_id" json:"-"`
        SimilarityID     string     `db:"similarity_id" json:"similarityID"`
        FileID           string     `db:"file_id" json:"-"`
        FileName         string     `db:"file_name" json:"fileName"`
        QueryID          string     `db:"query_id" json:"queryID"`
        QueryName        string     `db:"query_name" json:"queryName"`
        QueryURI         string     `json:"-"`
        Category         string     `json:"category"`
        Description      string     `json:"description"`
        Platform         string     `db:"platform" json:"platform"`
        Severity         Severity   `json:"severity"`
        Line             int        `json:"line"`
        VulnLines        []CodeLine `json:"vulnLines"`
        IssueType        IssueType  `db:"issue_type" json:"issueType"`
        SearchKey        string     `db:"search_key" json:"searchKey"`
        SearchValue      string     `db:"search_value" json:"searchValue"`
        KeyExpectedValue string     `db:"key_expected_value" json:"expectedValue"`
        KeyActualValue   string     `db:"key_actual_value" json:"actualValue"`
        Value            *string    `db:"value" json:"value"`
        Output           string     `json:"-"`
}

// QueryConfig is a struct that contains the fileKind and platform of the rego query
type QueryConfig struct {
        FileKind []FileKind
        Platform string
}

// ResolvedFiles keeps the information of all file/template resolved
type ResolvedFiles struct {
        File []ResolvedFile
}

// ResolvedFile keeps the information of a file/template resolved
type ResolvedFile struct {
        FileName     string
        Content      []byte
        OriginalData []byte
        SplitID      string
        IDInfo       map[int]interface{}
}

// Extensions represents a list of supported extensions
type Extensions map[string]struct{}

// Include returns true if an extension is included in supported extensions listed
// otherwise returns false
func (e Extensions) Include(ext string) bool <span class="cov1" title="1">{
        _, b := e[ext]

        return b
}</span>

// MatchedFilesRegex returns the regex rule to identify if an extension is supported or not
func (e Extensions) MatchedFilesRegex() string <span class="cov10" title="4">{
        if len(e) == 0 </span><span class="cov5" title="2">{
                return "NO_MATCHED_FILES"
        }</span>

        <span class="cov5" title="2">var parts []string
        for ext := range e </span><span class="cov8" title="3">{
                parts = append(parts, "\\"+ext)
        }</span>

        <span class="cov5" title="2">sort.Strings(parts)

        return "(.*)(" + strings.Join(parts, "|") + ")$"</span>
}

// FileMetadatas is a slice of FileMetadata
type FileMetadatas []FileMetadata

// ToMap creates a map of FileMetadatas, which the key is the FileMedata ID and the value is the FileMetadata
func (m FileMetadatas) ToMap() map[string]FileMetadata <span class="cov1" title="1">{
        c := make(map[string]FileMetadata, len(m))
        for i := 0; i &lt; len(m); i++ </span><span class="cov1" title="1">{
                c[m[i].ID] = m[i]
        }</span>
        <span class="cov1" title="1">return c</span>
}

// Documents (easyjson:json)
type Documents struct {
        Documents []Document `json:"document"`
}

// Document (easyjson:json)
type Document map[string]interface{}

// Combine merge documents from FileMetadatas using the ID as reference for Document ID and FileName as reference for file
func (m FileMetadatas) Combine() Documents <span class="cov5" title="2">{
        documents := Documents{Documents: make([]Document, 0, len(m))}
        for i := 0; i &lt; len(m); i++ </span><span class="cov5" title="2">{
                if len(m[i].Document) == 0 </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov1" title="1">m[i].Document["id"] = m[i].ID
                m[i].Document["file"] = m[i].FileName
                documents.Documents = append(documents.Documents, m[i].Document)</span>
        }
        <span class="cov5" title="2">return documents</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// Code generated by easyjson for marshaling/unmarshaling. DO NOT EDIT.

package model

import (
        json "encoding/json"
        easyjson "github.com/mailru/easyjson"
        jlexer "github.com/mailru/easyjson/jlexer"
        jwriter "github.com/mailru/easyjson/jwriter"
)

// suppress unused package warning
var (
        _ *json.RawMessage
        _ *jlexer.Lexer
        _ *jwriter.Writer
        _ easyjson.Marshaler
)

func easyjsonC80ae7adDecodeGithubComCheckmarxKicsPkgModel(in *jlexer.Lexer, out *Documents) <span class="cov0" title="0">{
        isTopLevel := in.IsStart()
        if in.IsNull() </span><span class="cov0" title="0">{
                if isTopLevel </span><span class="cov0" title="0">{
                        in.Consumed()
                }</span>
                <span class="cov0" title="0">in.Skip()
                return</span>
        }
        <span class="cov0" title="0">in.Delim('{')
        for !in.IsDelim('}') </span><span class="cov0" title="0">{
                key := in.UnsafeFieldName(false)
                in.WantColon()
                if in.IsNull() </span><span class="cov0" title="0">{
                        in.Skip()
                        in.WantComma()
                        continue</span>
                }
                <span class="cov0" title="0">switch key </span>{
                case "document":<span class="cov0" title="0">
                        if in.IsNull() </span><span class="cov0" title="0">{
                                in.Skip()
                                out.Documents = nil
                        }</span> else<span class="cov0" title="0"> {
                                in.Delim('[')
                                if out.Documents == nil </span><span class="cov0" title="0">{
                                        if !in.IsDelim(']') </span><span class="cov0" title="0">{
                                                out.Documents = make([]Document, 0, 8)
                                        }</span> else<span class="cov0" title="0"> {
                                                out.Documents = []Document{}
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        out.Documents = (out.Documents)[:0]
                                }</span>
                                <span class="cov0" title="0">for !in.IsDelim(']') </span><span class="cov0" title="0">{
                                        var v1 Document
                                        (v1).UnmarshalEasyJSON(in)
                                        out.Documents = append(out.Documents, v1)
                                        in.WantComma()
                                }</span>
                                <span class="cov0" title="0">in.Delim(']')</span>
                        }
                default:<span class="cov0" title="0">
                        in.SkipRecursive()</span>
                }
                <span class="cov0" title="0">in.WantComma()</span>
        }
        <span class="cov0" title="0">in.Delim('}')
        if isTopLevel </span><span class="cov0" title="0">{
                in.Consumed()
        }</span>
}
func easyjsonC80ae7adEncodeGithubComCheckmarxKicsPkgModel(out *jwriter.Writer, in Documents) <span class="cov0" title="0">{
        out.RawByte('{')
        first := true
        _ = first
        </span><span class="cov0" title="0">{
                const prefix string = ",\"document\":"
                out.RawString(prefix[1:])
                if in.Documents == nil &amp;&amp; (out.Flags&amp;jwriter.NilSliceAsEmpty) == 0 </span><span class="cov0" title="0">{
                        out.RawString("null")
                }</span> else<span class="cov0" title="0"> {
                        out.RawByte('[')
                        for v2, v3 := range in.Documents </span><span class="cov0" title="0">{
                                if v2 &gt; 0 </span><span class="cov0" title="0">{
                                        out.RawByte(',')
                                }</span>
                                <span class="cov0" title="0">(v3).MarshalEasyJSON(out)</span>
                        }
                        <span class="cov0" title="0">out.RawByte(']')</span>
                }
        }
        <span class="cov0" title="0">out.RawByte('}')</span>
}

// MarshalJSON supports json.Marshaler interface
func (v Documents) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        w := jwriter.Writer{}
        easyjsonC80ae7adEncodeGithubComCheckmarxKicsPkgModel(&amp;w, v)
        return w.Buffer.BuildBytes(), w.Error
}</span>

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v Documents) MarshalEasyJSON(w *jwriter.Writer) <span class="cov0" title="0">{
        easyjsonC80ae7adEncodeGithubComCheckmarxKicsPkgModel(w, v)
}</span>

// UnmarshalJSON supports json.Unmarshaler interface
func (v *Documents) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        r := jlexer.Lexer{Data: data}
        easyjsonC80ae7adDecodeGithubComCheckmarxKicsPkgModel(&amp;r, v)
        return r.Error()
}</span>

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *Documents) UnmarshalEasyJSON(l *jlexer.Lexer) <span class="cov0" title="0">{
        easyjsonC80ae7adDecodeGithubComCheckmarxKicsPkgModel(l, v)
}</span>
func easyjsonC80ae7adDecodeGithubComCheckmarxKicsPkgModel1(in *jlexer.Lexer, out *Document) <span class="cov0" title="0">{
        isTopLevel := in.IsStart()
        if in.IsNull() </span><span class="cov0" title="0">{
                in.Skip()
        }</span> else<span class="cov0" title="0"> {
                in.Delim('{')
                *out = make(Document)
                for !in.IsDelim('}') </span><span class="cov0" title="0">{
                        key := string(in.String())
                        in.WantColon()
                        var v4 interface{}
                        if m, ok := v4.(easyjson.Unmarshaler); ok </span><span class="cov0" title="0">{
                                m.UnmarshalEasyJSON(in)
                        }</span> else<span class="cov0" title="0"> if m, ok := v4.(json.Unmarshaler); ok </span><span class="cov0" title="0">{
                                _ = m.UnmarshalJSON(in.Raw())
                        }</span> else<span class="cov0" title="0"> {
                                v4 = in.Interface()
                        }</span>
                        <span class="cov0" title="0">(*out)[key] = v4
                        in.WantComma()</span>
                }
                <span class="cov0" title="0">in.Delim('}')</span>
        }
        <span class="cov0" title="0">if isTopLevel </span><span class="cov0" title="0">{
                in.Consumed()
        }</span>
}
func easyjsonC80ae7adEncodeGithubComCheckmarxKicsPkgModel1(out *jwriter.Writer, in Document) <span class="cov0" title="0">{
        if in == nil &amp;&amp; (out.Flags&amp;jwriter.NilMapAsEmpty) == 0 </span><span class="cov0" title="0">{
                out.RawString(`null`)
        }</span> else<span class="cov0" title="0"> {
                out.RawByte('{')
                v5First := true
                for v5Name, v5Value := range in </span><span class="cov0" title="0">{
                        if v5First </span><span class="cov0" title="0">{
                                v5First = false
                        }</span> else<span class="cov0" title="0"> {
                                out.RawByte(',')
                        }</span>
                        <span class="cov0" title="0">out.String(string(v5Name))
                        out.RawByte(':')
                        if m, ok := v5Value.(easyjson.Marshaler); ok </span><span class="cov0" title="0">{
                                m.MarshalEasyJSON(out)
                        }</span> else<span class="cov0" title="0"> if m, ok := v5Value.(json.Marshaler); ok </span><span class="cov0" title="0">{
                                out.Raw(m.MarshalJSON())
                        }</span> else<span class="cov0" title="0"> {
                                out.Raw(json.Marshal(v5Value))
                        }</span>
                }
                <span class="cov0" title="0">out.RawByte('}')</span>
        }
}

// MarshalJSON supports json.Marshaler interface
func (v Document) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        w := jwriter.Writer{}
        easyjsonC80ae7adEncodeGithubComCheckmarxKicsPkgModel1(&amp;w, v)
        return w.Buffer.BuildBytes(), w.Error
}</span>

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v Document) MarshalEasyJSON(w *jwriter.Writer) <span class="cov0" title="0">{
        easyjsonC80ae7adEncodeGithubComCheckmarxKicsPkgModel1(w, v)
}</span>

// UnmarshalJSON supports json.Unmarshaler interface
func (v *Document) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        r := jlexer.Lexer{Data: data}
        easyjsonC80ae7adDecodeGithubComCheckmarxKicsPkgModel1(&amp;r, v)
        return r.Error()
}</span>

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *Document) UnmarshalEasyJSON(l *jlexer.Lexer) <span class="cov0" title="0">{
        easyjsonC80ae7adDecodeGithubComCheckmarxKicsPkgModel1(l, v)
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package model

import (
        "path/filepath"

        "github.com/Checkmarx/kics/internal/constants"
        "github.com/rs/zerolog/log"
)

var categoriesNotFound = make(map[string]bool)

var severityLevelEquivalence = map[Severity]string{
        "INFO":   "none",
        "LOW":    "note",
        "MEDIUM": "warning",
        "HIGH":   "error",
}

var targetTemplate = sarifDescriptorReference{
        ToolComponent: sarifComponentReference{
                ComponentReferenceGUID:  "58cdcc6f-fe41-4724-bfb3-131a93df4c3f",
                ComponentReferenceName:  "Categories",
                ComponentReferenceIndex: 0,
        },
}

type ruleMetadata struct {
        queryID          string
        queryName        string
        queryDescription string
        queryURI         string
        queryCategory    string
        severity         Severity
}

type sarifMessage struct {
        Text string `json:"text"`
}

type sarifComponentReference struct {
        ComponentReferenceName  string `json:"name"`
        ComponentReferenceGUID  string `json:"guid"`
        ComponentReferenceIndex int    `json:"index"`
}

type sarifDescriptorReference struct {
        ReferenceID    string                  `json:"id"`
        ReferenceIndex int                     `json:"index"`
        ToolComponent  sarifComponentReference `json:"toolComponent"`
}

type sarifDescriptorRelationship struct {
        Target sarifDescriptorReference `json:"target"`
}

type sarifConfiguration struct {
        Level string `json:"level"`
}

type sarifRule struct {
        RuleID               string                        `json:"id"`
        RuleName             string                        `json:"name"`
        RuleShortDescription sarifMessage                  `json:"shortDescription"`
        RuleFullDescription  sarifMessage                  `json:"fullDescription"`
        DefaultConfiguration sarifConfiguration            `json:"defaultConfiguration"`
        HelpURI              string                        `json:"helpUri"`
        RuleRelationships    []sarifDescriptorRelationship `json:"relationships"`
}

type sarifDriver struct {
        ToolName     string      `json:"name"`
        ToolVersion  string      `json:"version"`
        ToolFullName string      `json:"fullName"`
        ToolURI      string      `json:"informationUri"`
        Rules        []sarifRule `json:"rules"`
}

type sarifTool struct {
        Driver sarifDriver `json:"driver"`
}

type sarifRegion struct {
        StartLine int `json:"startLine"`
}

type sarifArtifactLocation struct {
        ArtifactURI string `json:"uri"`
}

type sarifPhysicalLocation struct {
        ArtifactLocation sarifArtifactLocation `json:"artifactLocation"`
        Region           sarifRegion           `json:"region"`
}

type sarifLocation struct {
        PhysicalLocation sarifPhysicalLocation `json:"physicalLocation"`
}

type sarifResult struct {
        ResultRuleID    string          `json:"ruleId"`
        ResultRuleIndex int             `json:"ruleIndex"`
        ResultKind      string          `json:"kind"`
        ResultMessage   sarifMessage    `json:"message"`
        ResultLocations []sarifLocation `json:"locations"`
}

type sarifTaxanomyDefinition struct {
        DefinitionID               string       `json:"id"`
        DefinitionName             string       `json:"name"`
        DefinitionShortDescription sarifMessage `json:"shortDescription"`
        DefinitionFullDescription  sarifMessage `json:"fullDescription"`
}

type sarifTaxonomy struct {
        TaxonomyGUID             string                    `json:"guid"`
        TaxonomyName             string                    `json:"name"`
        TaxonomyFullDescription  sarifMessage              `json:"fullDescription"`
        TaxonomyShortDescription sarifMessage              `json:"shortDescription"`
        TaxonomyDefinitions      []sarifTaxanomyDefinition `json:"taxa"`
}

type sarifRun struct {
        Tool       sarifTool       `json:"tool"`
        Results    []sarifResult   `json:"results"`
        Taxonomies []sarifTaxonomy `json:"taxonomies"`
}

// SarifReport represents a usable sarif report reference
type SarifReport interface {
        BuildIssue(issue *VulnerableQuery)
}

type sarifReport struct {
        basePath     string     `json:"-"`
        Schema       string     `json:"$schema"`
        SarifVersion string     `json:"version"`
        Runs         []sarifRun `json:"runs"`
}

func initTool() sarifTool <span class="cov4" title="5">{
        return sarifTool{
                Driver: sarifDriver{
                        ToolName:     "KICS",
                        ToolVersion:  constants.Version,
                        ToolFullName: constants.Fullname,
                        ToolURI:      "https://www.kics.io/",
                        Rules:        make([]sarifRule, 0),
                },
        }
}</span>

func initCategories() []sarifTaxanomyDefinition <span class="cov4" title="5">{
        allCategories := []sarifTaxanomyDefinition{noCategory}
        for _, category := range categories </span><span class="cov10" title="70">{
                allCategories = append(allCategories, category)
        }</span>
        <span class="cov4" title="5">return allCategories</span>
}

func initTaxonomies() []sarifTaxonomy <span class="cov4" title="5">{
        return []sarifTaxonomy{
                {
                        TaxonomyGUID: targetTemplate.ToolComponent.ComponentReferenceGUID,
                        TaxonomyName: targetTemplate.ToolComponent.ComponentReferenceName,
                        TaxonomyShortDescription: sarifMessage{
                                Text: "Vulnerabilities categories",
                        },
                        TaxonomyFullDescription: sarifMessage{
                                Text: "This taxonomy contains the types an issue can assume",
                        },
                        TaxonomyDefinitions: initCategories(),
                },
        }
}</span>

func initRun() []sarifRun <span class="cov4" title="5">{
        return []sarifRun{
                {
                        Tool:       initTool(),
                        Results:    make([]sarifResult, 0),
                        Taxonomies: initTaxonomies(),
                },
        }
}</span>

// NewSarifReport creates and start a new sarif report with default values respecting SARIF schema 2.1.0
func NewSarifReport() SarifReport <span class="cov3" title="4">{
        return &amp;sarifReport{
                Schema:       "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
                SarifVersion: "2.1.0",
                Runs:         initRun(),
        }
}</span>

func (sr *sarifReport) findCategory(category string) int <span class="cov3" title="3">{
        for idx, taxonomy := range sr.Runs[0].Taxonomies[0].TaxonomyDefinitions </span><span class="cov9" title="45">{
                if taxonomy.DefinitionName == category </span><span class="cov0" title="0">{
                        return idx
                }</span>
        }
        <span class="cov3" title="3">return 0</span>
}

func (sr *sarifReport) buildCategory(category string) sarifDescriptorReference <span class="cov3" title="3">{
        target := targetTemplate
        categoryIndex := sr.findCategory(category)
        target.ReferenceIndex = categoryIndex
        target.ReferenceID = sr.Runs[0].Taxonomies[0].TaxonomyDefinitions[categoryIndex].DefinitionID
        if categoryIndex == 0 </span><span class="cov3" title="3">{
                if _, exists := categoriesNotFound[category]; !exists </span><span class="cov2" title="2">{
                        log.Warn().Msgf("Category %s not found.", category)
                        categoriesNotFound[category] = true
                }</span>
        }
        <span class="cov3" title="3">return target</span>
}

func (sr *sarifReport) findRuleIndex(ruleID string) int <span class="cov3" title="4">{
        for idx, rule := range sr.Runs[0].Tool.Driver.Rules </span><span class="cov2" title="2">{
                if rule.RuleID == ruleID </span><span class="cov1" title="1">{
                        return idx
                }</span>
        }
        <span class="cov3" title="3">return -1</span>
}

func (sr *sarifReport) buildRule(queryMetadata *ruleMetadata) int <span class="cov3" title="4">{
        index := sr.findRuleIndex(queryMetadata.queryID)
        if index &lt; 0 </span><span class="cov3" title="3">{
                helpURI := "https://docs.kics.io/"
                if queryMetadata.queryURI != "" </span><span class="cov3" title="3">{
                        helpURI = queryMetadata.queryURI
                }</span>
                <span class="cov3" title="3">rule := sarifRule{
                        RuleID:               queryMetadata.queryID,
                        RuleName:             queryMetadata.queryName,
                        RuleShortDescription: sarifMessage{Text: queryMetadata.queryName},
                        RuleFullDescription:  sarifMessage{Text: queryMetadata.queryDescription},
                        DefaultConfiguration: sarifConfiguration{Level: severityLevelEquivalence[queryMetadata.severity]},
                        RuleRelationships:    []sarifDescriptorRelationship{{Target: sr.buildCategory(queryMetadata.queryCategory)}},
                        HelpURI:              helpURI,
                }

                sr.Runs[0].Tool.Driver.Rules = append(sr.Runs[0].Tool.Driver.Rules, rule)
                index = len(sr.Runs[0].Tool.Driver.Rules) - 1</span>
        }
        <span class="cov3" title="4">return index</span>
}

// BuildIssue creates a new entries in Results (one for each file) and new entry in Rules and Taxonomy if necessary
func (sr *sarifReport) BuildIssue(issue *VulnerableQuery) <span class="cov4" title="5">{
        if len(issue.Files) &gt; 0 </span><span class="cov3" title="4">{
                absBasePath, err := filepath.Abs(sr.basePath)
                if err != nil </span><span class="cov0" title="0">{
                        log.Err(err)
                }</span>
                <span class="cov3" title="4">metadata := ruleMetadata{
                        queryID:          issue.QueryID,
                        queryName:        issue.QueryName,
                        queryDescription: issue.Description,
                        queryURI:         issue.QueryURI,
                        queryCategory:    issue.Category,
                        severity:         issue.Severity,
                }
                ruleIndex := sr.buildRule(&amp;metadata)
                kind := "fail"
                if severityLevelEquivalence[issue.Severity] == "none" </span><span class="cov1" title="1">{
                        kind = "informational"
                }</span>
                <span class="cov3" title="4">for idx := range issue.Files </span><span class="cov3" title="4">{
                        relativePath, _ := filepath.Rel(absBasePath, issue.Files[idx].FileName)
                        result := sarifResult{
                                ResultRuleID:    issue.QueryID,
                                ResultRuleIndex: ruleIndex,
                                ResultKind:      kind,
                                ResultMessage:   sarifMessage{Text: issue.Files[idx].KeyActualValue},
                                ResultLocations: []sarifLocation{
                                        {
                                                PhysicalLocation: sarifPhysicalLocation{
                                                        ArtifactLocation: sarifArtifactLocation{ArtifactURI: relativePath},
                                                        Region:           sarifRegion{StartLine: issue.Files[idx].Line},
                                                },
                                        },
                                },
                        }
                        sr.Runs[0].Results = append(sr.Runs[0].Results, result)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package model

import (
        "sort"

        "github.com/rs/zerolog/log"
)

// SeveritySummary contains scans' result numbers, how many vulnerabilities of each severity was detected
type SeveritySummary struct {
        ScanID           string           `json:"scan_id"`
        SeverityCounters map[Severity]int `json:"severity_counters"`
        TotalCounter     int              `json:"total_counter"`
}

// VulnerableFile contains information of a vulnerable file and where the vulnerability was found
type VulnerableFile struct {
        FileName         string     `json:"file_name"`
        SimilarityID     string     `json:"similarity_id"`
        Line             int        `json:"line"`
        VulnLines        []CodeLine `json:"-"`
        IssueType        IssueType  `json:"issue_type"`
        SearchKey        string     `json:"search_key"`
        SearchValue      string     `json:"search_value"`
        KeyExpectedValue string     `json:"expected_value"`
        KeyActualValue   string     `json:"actual_value"`
        Value            *string    `json:"value"`
}

// VulnerableQuery contains a query that tested positive ID, name, severity and a list of files that tested vulnerable
type VulnerableQuery struct {
        QueryName   string           `json:"query_name"`
        QueryID     string           `json:"query_id"`
        QueryURI    string           `json:"query_url"`
        Severity    Severity         `json:"severity"`
        Platform    string           `json:"platform"`
        Files       []VulnerableFile `json:"files"`
        Category    string           `json:"category"`
        Description string           `json:"description"`
}

// VulnerableQuerySlice is a slice of VulnerableQuery
type VulnerableQuerySlice []VulnerableQuery

// Counters hold information about how many files were scanned, parsed, failed to be scaned, the total of queries
// and how many queries failed to execute
type Counters struct {
        ScannedFiles           int `json:"files_scanned"`
        ParsedFiles            int `json:"files_parsed"`
        FailedToScanFiles      int `json:"files_failed_to_scan"`
        TotalQueries           int `json:"queries_total"`
        FailedToExecuteQueries int `json:"queries_failed_to_execute"`
        FailedSimilarityID     int `json:"queries_failed_to_compute_similarity_id"`
}

// Summary is a report of a single scan
type Summary struct {
        Counters
        Queries VulnerableQuerySlice `json:"queries"`
        SeveritySummary
}

// CreateSummary creates a report for a single scan, based on its scanID
func CreateSummary(counters Counters, vulnerabilities []Vulnerability, scanID string) Summary <span class="cov10" title="2">{
        log.Debug().Msg("model.CreateSummary()")
        q := make(map[string]VulnerableQuery, len(vulnerabilities))
        severitySummary := SeveritySummary{
                ScanID: scanID,
        }
        for i := range vulnerabilities </span><span class="cov1" title="1">{
                item := vulnerabilities[i]
                if _, ok := q[item.QueryName]; !ok </span><span class="cov1" title="1">{
                        q[item.QueryName] = VulnerableQuery{
                                QueryName:   item.QueryName,
                                QueryID:     item.QueryID,
                                Severity:    item.Severity,
                                QueryURI:    item.QueryURI,
                                Platform:    item.Platform,
                                Category:    item.Category,
                                Description: item.Description,
                        }
                }</span>

                <span class="cov1" title="1">qItem := q[item.QueryName]
                qItem.Files = append(qItem.Files, VulnerableFile{
                        FileName:         item.FileName,
                        SimilarityID:     item.SimilarityID,
                        Line:             item.Line,
                        VulnLines:        item.VulnLines,
                        IssueType:        item.IssueType,
                        SearchKey:        item.SearchKey,
                        SearchValue:      item.SearchValue,
                        KeyExpectedValue: item.KeyExpectedValue,
                        KeyActualValue:   item.KeyActualValue,
                        Value:            item.Value,
                })

                q[item.QueryName] = qItem</span>
        }

        <span class="cov10" title="2">queries := make([]VulnerableQuery, 0, len(q))
        sevs := map[Severity]int{SeverityInfo: 0, SeverityLow: 0, SeverityMedium: 0, SeverityHigh: 0}
        for idx := range q </span><span class="cov1" title="1">{
                queries = append(queries, q[idx])
                sevs[q[idx].Severity] += len(q[idx].Files)
                severitySummary.TotalCounter += len(q[idx].Files)
        }</span>

        <span class="cov10" title="2">severityOrder := map[Severity]int{SeverityInfo: 3, SeverityLow: 2, SeverityMedium: 1, SeverityHigh: 0}
        sort.Slice(queries, func(i, j int) bool </span><span class="cov0" title="0">{
                if severityOrder[queries[i].Severity] == severityOrder[queries[j].Severity] </span><span class="cov0" title="0">{
                        return queries[i].QueryName &lt; queries[j].QueryName
                }</span>
                <span class="cov0" title="0">return severityOrder[queries[i].Severity] &lt; severityOrder[queries[j].Severity]</span>
        })

        <span class="cov10" title="2">severitySummary.SeverityCounters = sevs

        return Summary{
                Counters:        counters,
                Queries:         queries,
                SeveritySummary: severitySummary,
        }</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package docker

import (
        "bytes"
        "encoding/json"
        "strings"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/moby/buildkit/frontend/dockerfile/parser"
        "github.com/pkg/errors"
)

// Parser is a Dockerfile parser
type Parser struct {
}

// Resource Separates the list of commands by file
type Resource struct {
        CommandList map[string][]Command `json:"command"`
}

// Command is the struct for each dockerfile command
type Command struct {
        Cmd       string
        SubCmd    string
        Flags     []string
        Value     []string
        Original  string
        StartLine int
        EndLine   int
        JSON      bool
}

// Resolve - replace or modifies in-memory content before parsing
func (p *Parser) Resolve(fileContent []byte, filename string) (*[]byte, error) <span class="cov1" title="1">{
        return &amp;fileContent, nil
}</span>

// Parse - parses dockerfile to Json
func (p *Parser) Parse(_ string, fileContent []byte) ([]model.Document, error) <span class="cov3" title="3">{
        var documents []model.Document
        reader := bytes.NewReader(fileContent)

        parsed, err := parser.Parse(reader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to parse Dockerfile")
        }</span>

        <span class="cov3" title="3">fromValue := "args"
        from := make(map[string][]Command)

        for _, child := range parsed.AST.Children </span><span class="cov8" title="21">{
                if child.Value == "from" </span><span class="cov4" title="4">{
                        fromValue = strings.TrimPrefix(child.Original, "FROM ")
                }</span>

                <span class="cov8" title="21">cmd := Command{
                        Cmd:       child.Value,
                        Original:  child.Original,
                        Flags:     child.Flags,
                        StartLine: child.StartLine,
                        EndLine:   child.EndLine,
                }

                if child.Next != nil &amp;&amp; len(child.Next.Children) &gt; 0 </span><span class="cov2" title="2">{
                        cmd.SubCmd = child.Next.Children[0].Value
                        child = child.Next.Children[0]
                }</span>

                <span class="cov8" title="21">cmd.JSON = child.Attributes["json"]
                for n := child.Next; n != nil; n = n.Next </span><span class="cov10" title="31">{
                        cmd.Value = append(cmd.Value, n.Value)
                }</span>

                <span class="cov8" title="21">from[fromValue] = append(from[fromValue], cmd)</span>
        }

        <span class="cov3" title="3">doc := &amp;model.Document{}
        var resource Resource
        resource.CommandList = from

        j, err := json.Marshal(resource)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to Marshal Dockerfile")
        }</span>

        <span class="cov3" title="3">if err := json.Unmarshal(j, &amp;doc); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to Unmarshal Dockerfile")
        }</span>

        <span class="cov3" title="3">documents = append(documents, *doc)

        return documents, nil</span>
}

// GetKind returns the kind of the parser
func (p *Parser) GetKind() model.FileKind <span class="cov1" title="1">{
        return model.KindDOCKER
}</span>

// SupportedExtensions returns Dockerfile extensions
func (p *Parser) SupportedExtensions() []string <span class="cov1" title="1">{
        return []string{"Dockerfile", ".dockerfile"}
}</span>

// SupportedTypes returns types supported by this parser, which are dockerfile
func (p *Parser) SupportedTypes() []string <span class="cov1" title="1">{
        return []string{"Dockerfile"}
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package json

import (
        "encoding/json"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/pkg/errors"
)

// Parser defines a parser type
type Parser struct {
}

// Resolve - replace or modifies in-memory content before parsing
func (p *Parser) Resolve(fileContent []byte, filename string) (*[]byte, error) <span class="cov8" title="1">{
        return &amp;fileContent, nil
}</span>

// Parse parses json file and returns it as a Document
func (p *Parser) Parse(_ string, fileContent []byte) ([]model.Document, error) <span class="cov8" title="1">{
        r := model.Document{}
        err := json.Unmarshal(fileContent, &amp;r)
        if err != nil </span><span class="cov0" title="0">{
                r := []model.Document{}
                err = json.Unmarshal(fileContent, &amp;r)
                return r, err
        }</span>

        <span class="cov8" title="1">return []model.Document{r}, errors.Wrap(err, "failed to unmarshall json content")</span>
}

// SupportedExtensions returns extensions supported by this parser, which is json extension
func (p *Parser) SupportedExtensions() []string <span class="cov8" title="1">{
        return []string{".json"}
}</span>

// GetKind returns JSON constant kind
func (p *Parser) GetKind() model.FileKind <span class="cov8" title="1">{
        return model.KindJSON
}</span>

// SupportedTypes returns types supported by this parser, which are cloudFormation
func (p *Parser) SupportedTypes() []string <span class="cov8" title="1">{
        return []string{"CloudFormation", "OpenAPI"}
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package parser

import (
        "errors"
        "fmt"
        "path/filepath"
        "strings"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/rs/zerolog/log"
)

type kindParser interface {
        GetKind() model.FileKind
        SupportedExtensions() []string
        SupportedTypes() []string
        Parse(filePath string, fileContent []byte) ([]model.Document, error)
        Resolve(fileContent []byte, filename string) (*[]byte, error)
}

// Builder is a representation of parsers that will be construct
type Builder struct {
        parsers []kindParser
}

// NewBuilder creates a new Builder's reference
func NewBuilder() *Builder <span class="cov3" title="3">{
        log.Debug().Msg("parser.NewBuilder()")
        return &amp;Builder{}
}</span>

// Add is a function that adds a new parser to the caller and returns it
func (b *Builder) Add(p kindParser) *Builder <span class="cov6" title="8">{
        b.parsers = append(b.parsers, p)
        return b
}</span>

// Build prepares parsers and associates a parser to its extension and returns it
func (b *Builder) Build(types []string) (*Parser, error) <span class="cov3" title="3">{
        var suportedTypes []string
        parsers := make(map[string]kindParser, len(b.parsers))
        extensions := make(model.Extensions, len(b.parsers))
        for _, parser := range b.parsers </span><span class="cov6" title="8">{
                suportedTypes = append(suportedTypes, parser.SupportedTypes()...)
                if _, _, ok := contains(types, parser.SupportedTypes()); ok </span><span class="cov6" title="8">{
                        for _, ext := range parser.SupportedExtensions() </span><span class="cov7" title="12">{
                                parsers[ext] = parser
                                extensions[ext] = struct{}{}
                        }</span>
                }
        }

        <span class="cov3" title="3">if err := validateArguments(types, suportedTypes); err != nil </span><span class="cov0" title="0">{
                return &amp;Parser{}, err
        }</span>

        <span class="cov3" title="3">return &amp;Parser{
                parsers:    parsers,
                extensions: extensions,
        }, nil</span>
}

// ErrNotSupportedFile represents an error when a file is not supported by KICS
var ErrNotSupportedFile = errors.New("unsupported file to parse")

// Parser is a struct that associates a parser to its supported extensions
type Parser struct {
        parsers    map[string]kindParser
        extensions model.Extensions
}

// Parse executes a parser on the fileContent and returns the file content as a Document, the file kind and
// an error, if an error has occurred
func (c *Parser) Parse(filePath string, fileContent []byte) ([]model.Document, model.FileKind, error) <span class="cov4" title="4">{
        ext := filepath.Ext(filePath)
        if ext == "" </span><span class="cov1" title="1">{
                ext = filepath.Base(filePath)
        }</span>
        <span class="cov4" title="4">if p, ok := c.parsers[ext]; ok </span><span class="cov3" title="3">{
                resolved, err := p.Resolve(fileContent, filePath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, "", err
                }</span>
                <span class="cov3" title="3">obj, err := p.Parse(filePath, *resolved)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, "", err
                }</span>

                <span class="cov3" title="3">return obj, p.GetKind(), nil</span>
        }

        <span class="cov1" title="1">return nil, "", ErrNotSupportedFile</span>
}

// SupportedExtensions returns extensions supported by KICS
func (c *Parser) SupportedExtensions() model.Extensions <span class="cov1" title="1">{
        return c.extensions
}</span>

func validateArguments(types, validArgs []string) error <span class="cov5" title="6">{
        validArgs = removeDuplicateValues(validArgs)
        if invalidType, ok, _ := contains(types, validArgs); !ok </span><span class="cov1" title="1">{
                return fmt.Errorf("unknown argument: %s\nvalid arguments:\n  %s", invalidType, strings.Join(validArgs, "\n  "))
        }</span>
        <span class="cov4" title="5">return nil</span>
}

func contains(types, supportedTypes []string) (invalidArgsRes []string, contRes, supportedRes bool) <span class="cov7" title="14">{
        if types[0] == "" </span><span class="cov6" title="11">{
                return []string{}, true, true
        }</span>
        <span class="cov3" title="3">set := make(map[string]struct{}, len(supportedTypes))
        for _, s := range supportedTypes </span><span class="cov7" title="15">{
                set[strings.ToUpper(s)] = struct{}{}
        }</span>
        <span class="cov3" title="3">cont := true
        supported := false
        var invalidArgs []string
        for _, item := range types </span><span class="cov3" title="3">{
                _, ok := set[strings.ToUpper(item)]
                if !ok </span><span class="cov1" title="1">{
                        cont = false
                        invalidArgs = append(invalidArgs, item)
                }</span> else<span class="cov2" title="2"> {
                        supported = true
                }</span>
        }
        <span class="cov3" title="3">return invalidArgs, cont, supported</span>
}

// function to remove duplicate values in array
func removeDuplicateValues(stringSlice []string) []string <span class="cov6" title="8">{
        keys := make(map[string]bool)
        list := []string{}

        for _, entry := range stringSlice </span><span class="cov10" title="38">{
                if _, value := keys[entry]; !value </span><span class="cov9" title="33">{
                        keys[entry] = true
                        list = append(list, entry)
                }</span>
        }
        <span class="cov6" title="8">return list</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package converter

import (
        "fmt"
        "strings"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/getsentry/sentry-go"
        "github.com/hashicorp/hcl/v2"
        "github.com/hashicorp/hcl/v2/hclsyntax"
        "github.com/rs/zerolog/log"
        "github.com/zclconf/go-cty/cty"
        ctyconvert "github.com/zclconf/go-cty/cty/convert"
        ctyjson "github.com/zclconf/go-cty/cty/json"
)

// InputVariableMap represents a set of terraform input variables
type InputVariableMap map[string]cty.Value

var inputVarMap = make(InputVariableMap)

// This file is attributed to https://github.com/tmccombs/hcl2json.
// convertBlock() is manipulated for combining the both blocks and labels for one given resource.

// DefaultConverted an hcl File to a toJson serializable object
// This assumes that the body is a hclsyntax.Body
var DefaultConverted = func(file *hcl.File, inputVariables InputVariableMap) (model.Document, error) <span class="cov4" title="5">{
        inputVarMap = inputVariables
        c := converter{bytes: file.Bytes}
        body, err := c.convertBody(file.Body.(*hclsyntax.Body))

        if err != nil </span><span class="cov0" title="0">{
                sentry.CaptureException(err)
                if er, ok := err.(*hcl.Diagnostic); ok &amp;&amp; er.Subject != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov4" title="5">return body, nil</span>
}

type converter struct {
        bytes []byte
}

func (c *converter) rangeSource(r hcl.Range) string <span class="cov8" title="19">{
        return string(c.bytes[r.Start.Byte:r.End.Byte])
}</span>

func (c *converter) convertBody(body *hclsyntax.Body) (model.Document, error) <span class="cov7" title="17">{
        var err error
        out := make(model.Document)
        for key, value := range body.Attributes </span><span class="cov8" title="26">{
                out[key], err = c.convertExpression(value.Expr)
                if err != nil </span><span class="cov0" title="0">{
                        sentry.CaptureException(err)
                        return nil, err
                }</span>
        }

        <span class="cov7" title="17">for _, block := range body.Blocks </span><span class="cov6" title="12">{
                err = c.convertBlock(block, out)
                if err != nil </span><span class="cov0" title="0">{
                        sentry.CaptureException(err)
                        return nil, err
                }</span>
        }

        <span class="cov7" title="17">return out, nil</span>
}

func (c *converter) convertBlock(block *hclsyntax.Block, out model.Document) error <span class="cov6" title="12">{
        var key = block.Type
        value, err := c.convertBody(block.Body)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="12">for _, label := range block.Labels </span><span class="cov6" title="10">{
                if inner, exists := out[key]; exists </span><span class="cov2" title="2">{
                        var ok bool
                        out, ok = inner.(model.Document)
                        if !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unable to convert Block to JSON: %v.%v", block.Type, strings.Join(block.Labels, "."))
                        }</span>
                } else<span class="cov5" title="8"> {
                        obj := make(model.Document)
                        out[key] = obj
                        out = obj
                }</span>
                <span class="cov6" title="10">key = label</span>
        }

        <span class="cov6" title="12">if current, exists := out[key]; exists </span><span class="cov3" title="3">{
                if list, ok := current.([]interface{}); ok </span><span class="cov1" title="1">{
                        out[key] = append(list, value)
                }</span> else<span class="cov2" title="2"> {
                        out[key] = []interface{}{current, value}
                }</span>
        } else<span class="cov6" title="9"> {
                out[key] = value
        }</span>

        <span class="cov6" title="12">return nil</span>
}

func (c *converter) convertExpression(expr hclsyntax.Expression) (interface{}, error) <span class="cov10" title="44">{
        // assume it is hcl syntax (because, um, it is)
        switch value := expr.(type) </span>{
        case *hclsyntax.LiteralValueExpr:<span class="cov6" title="10">
                return ctyjson.SimpleJSONValue{Value: value.Val}, nil</span>
        case *hclsyntax.TemplateExpr:<span class="cov7" title="17">
                return c.convertTemplate(value)</span>
        case *hclsyntax.TemplateWrapExpr:<span class="cov2" title="2">
                return c.convertExpression(value.Wrapped)</span>
        case *hclsyntax.TupleConsExpr:<span class="cov1" title="1">
                var list []interface{}
                for _, ex := range value.Exprs </span><span class="cov4" title="4">{
                        elem, err := c.convertExpression(ex)
                        if err != nil </span><span class="cov0" title="0">{
                                sentry.CaptureException(err)
                                return nil, err
                        }</span>
                        <span class="cov4" title="4">list = append(list, elem)</span>
                }
                <span class="cov1" title="1">return list, nil</span>
        case *hclsyntax.ObjectConsExpr:<span class="cov2" title="2">
                m := make(model.Document)
                for _, item := range value.Items </span><span class="cov6" title="12">{
                        key, err := c.convertKey(item.KeyExpr)
                        if err != nil </span><span class="cov0" title="0">{
                                sentry.CaptureException(err)
                                return nil, err
                        }</span>
                        <span class="cov6" title="12">m[key], err = c.convertExpression(item.ValueExpr)
                        if err != nil </span><span class="cov0" title="0">{
                                sentry.CaptureException(err)
                                return nil, err
                        }</span>
                }
                <span class="cov2" title="2">return m, nil</span>
        default:<span class="cov6" title="12">
                // try to evaluate with variables
                valueConverted, _ := expr.Value(&amp;hcl.EvalContext{
                        Variables: inputVarMap,
                })
                if !valueConverted.Type().HasDynamicTypes() </span><span class="cov6" title="9">{
                        return ctyjson.SimpleJSONValue{Value: valueConverted}, nil
                }</span>
                <span class="cov3" title="3">return c.wrapExpr(expr)</span>
        }
}

func (c *converter) convertKey(keyExpr hclsyntax.Expression) (string, error) <span class="cov6" title="12">{
        // a key should never have dynamic input
        if k, isKeyExpr := keyExpr.(*hclsyntax.ObjectConsKeyExpr); isKeyExpr </span><span class="cov6" title="12">{
                keyExpr = k.Wrapped
                if _, isTraversal := keyExpr.(*hclsyntax.ScopeTraversalExpr); isTraversal </span><span class="cov5" title="8">{
                        return c.rangeSource(keyExpr.Range()), nil
                }</span>
        }
        <span class="cov4" title="4">return c.convertStringPart(keyExpr)</span>
}

func (c *converter) convertTemplate(t *hclsyntax.TemplateExpr) (string, error) <span class="cov8" title="25">{
        if t.IsStringLiteral() </span><span class="cov7" title="18">{
                // safe because the value is just the string
                v, err := t.Value(nil)
                if err != nil </span><span class="cov0" title="0">{
                        sentry.CaptureException(err)
                        return "", err
                }</span>
                <span class="cov7" title="18">return v.AsString(), nil</span>
        }
        <span class="cov5" title="7">var builder strings.Builder
        for _, part := range t.Parts </span><span class="cov8" title="23">{
                s, err := c.convertStringPart(part)
                if err != nil </span><span class="cov0" title="0">{
                        sentry.CaptureException(err)
                        return "", err
                }</span>
                <span class="cov8" title="23">builder.WriteString(s)</span>
        }
        <span class="cov5" title="7">return builder.String(), nil</span>
}

func (c *converter) convertStringPart(expr hclsyntax.Expression) (string, error) <span class="cov9" title="33">{
        switch v := expr.(type) </span>{
        case *hclsyntax.LiteralValueExpr:<span class="cov7" title="15">
                s, err := ctyconvert.Convert(v.Val, cty.String)
                if err != nil </span><span class="cov0" title="0">{
                        sentry.CaptureException(err)
                        return "", err
                }</span>
                <span class="cov7" title="15">return s.AsString(), nil</span>
        case *hclsyntax.TemplateExpr:<span class="cov5" title="8">
                return c.convertTemplate(v)</span>
        case *hclsyntax.TemplateWrapExpr:<span class="cov1" title="1">
                return c.convertStringPart(v.Wrapped)</span>
        case *hclsyntax.ConditionalExpr:<span class="cov2" title="2">
                return c.convertTemplateConditional(v)</span>
        case *hclsyntax.TemplateJoinExpr:<span class="cov1" title="1">
                return c.convertTemplateFor(v.Tuple.(*hclsyntax.ForExpr))</span>
        default:<span class="cov5" title="6">
                // try to evaluate with variables
                valueConverted, _ := expr.Value(&amp;hcl.EvalContext{
                        Variables: inputVarMap,
                })
                if valueConverted.Type().FriendlyName() == "string" </span><span class="cov1" title="1">{
                        return valueConverted.AsString(), nil
                }</span>
                // treating as an embedded expression
                <span class="cov4" title="5">return c.wrapExpr(expr)</span>
        }
}

func (c *converter) convertTemplateConditional(expr *hclsyntax.ConditionalExpr) (string, error) <span class="cov2" title="2">{
        var builder strings.Builder
        builder.WriteString("%{if ")
        builder.WriteString(c.rangeSource(expr.Condition.Range()))
        builder.WriteString("}")
        trueResult, err := c.convertStringPart(expr.TrueResult)
        if err != nil </span><span class="cov0" title="0">{
                sentry.CaptureException(err)
                return "", nil
        }</span>
        <span class="cov2" title="2">builder.WriteString(trueResult)
        falseResult, err := c.convertStringPart(expr.FalseResult)
        if err != nil </span><span class="cov0" title="0">{
                sentry.CaptureException(err)
                return "", nil
        }</span>
        <span class="cov2" title="2">if len(falseResult) &gt; 0 </span><span class="cov1" title="1">{
                builder.WriteString("%{else}")
                builder.WriteString(falseResult)
        }</span>
        <span class="cov2" title="2">builder.WriteString("%{endif}")

        return builder.String(), nil</span>
}

func (c *converter) convertTemplateFor(expr *hclsyntax.ForExpr) (string, error) <span class="cov1" title="1">{
        var builder strings.Builder
        builder.WriteString("%{for ")
        if len(expr.KeyVar) &gt; 0 </span><span class="cov0" title="0">{
                builder.WriteString(expr.KeyVar)
                builder.WriteString(", ")
        }</span>
        <span class="cov1" title="1">builder.WriteString(expr.ValVar)
        builder.WriteString(" in ")
        builder.WriteString(c.rangeSource(expr.CollExpr.Range()))
        builder.WriteString("}")
        templ, err := c.convertStringPart(expr.ValExpr)
        if err != nil </span><span class="cov0" title="0">{
                sentry.CaptureException(err)
                return "", err
        }</span>
        <span class="cov1" title="1">builder.WriteString(templ)
        builder.WriteString("%{endfor}")

        return builder.String(), nil</span>
}

func (c *converter) wrapExpr(expr hclsyntax.Expression) (string, error) <span class="cov5" title="8">{
        expression := c.rangeSource(expr.Range())
        if strings.HasPrefix(expression, "var.") </span><span class="cov3" title="3">{
                log.Warn().Msgf("Variable ${%s} value not found", expression)
        }</span>
        <span class="cov5" title="8">return "${" + expression + "}", nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package terraform

import (
        "path/filepath"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/Checkmarx/kics/pkg/parser/terraform/converter"
        "github.com/hashicorp/hcl/v2"
        "github.com/hashicorp/hcl/v2/hclsyntax"
        "github.com/pkg/errors"
)

// RetriesDefaultValue is default number of times a parser will retry to execute
const RetriesDefaultValue = 50

// Converter returns content json, error line, error
type Converter func(file *hcl.File, inputVariables converter.InputVariableMap) (model.Document, error)

// Parser struct that contains the function to parse file and the number of retries if something goes wrong
type Parser struct {
        convertFunc  Converter
        numOfRetries int
}

// NewDefault initializes a parser with Parser default values
func NewDefault() *Parser <span class="cov10" title="2">{
        return &amp;Parser{
                numOfRetries: RetriesDefaultValue,
                convertFunc:  converter.DefaultConverted,
        }
}</span>

// Resolve - replace or modifies in-memory content before parsing
func (p *Parser) Resolve(fileContent []byte, filename string) (*[]byte, error) <span class="cov1" title="1">{
        getInputVariables(filepath.Dir(filename))
        return &amp;fileContent, nil
}</span>

// Parse execute parser for the content in a file
func (p *Parser) Parse(path string, content []byte) ([]model.Document, error) <span class="cov1" title="1">{
        file, diagnostics := hclsyntax.ParseConfig(content, filepath.Base(path), hcl.Pos{Byte: 0, Line: 1, Column: 1})

        if diagnostics != nil &amp;&amp; diagnostics.HasErrors() &amp;&amp; len(diagnostics.Errs()) &gt; 0 </span><span class="cov0" title="0">{
                err := diagnostics.Errs()[0]
                return nil, err
        }</span>

        <span class="cov1" title="1">fc, parseErr := p.convertFunc(file, inputVariableMap)

        return []model.Document{fc}, errors.Wrap(parseErr, "failed terraform parse")</span>
}

// SupportedExtensions returns Terraform extensions
func (p *Parser) SupportedExtensions() []string <span class="cov1" title="1">{
        return []string{".tf"}
}</span>

// SupportedTypes returns types supported by this parser, which are terraform
func (p *Parser) SupportedTypes() []string <span class="cov1" title="1">{
        return []string{"Terraform"}
}</span>

// GetKind returns Terraform kind parser
func (p *Parser) GetKind() model.FileKind <span class="cov1" title="1">{
        return model.KindTerraform
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package terraform

import (
        "fmt"
        "os"
        "path/filepath"

        "github.com/Checkmarx/kics/pkg/parser/terraform/converter"
        "github.com/hashicorp/hcl/v2"
        "github.com/hashicorp/hcl/v2/hclsyntax"
        "github.com/rs/zerolog/log"
        "github.com/zclconf/go-cty/cty"
)

var inputVariableMap = make(converter.InputVariableMap)

func mergeMaps(baseMap, newItems converter.InputVariableMap) <span class="cov6" title="6">{
        for key, value := range newItems </span><span class="cov7" title="8">{
                baseMap[key] = value
        }</span>
}

func parseFile(filename string) (*hcl.File, error) <span class="cov10" title="16">{
        file, err := os.ReadFile(filename)
        if err != nil </span><span class="cov4" title="3">{
                return nil, err
        }</span>

        <span class="cov9" title="13">parsedFile, _ := hclsyntax.ParseConfig(file, filename, hcl.Pos{Line: 1, Column: 1})

        return parsedFile, nil</span>
}

func setInputVariablesDefaultValues(filename string) (converter.InputVariableMap, error) <span class="cov7" title="7">{
        parsedFile, err := parseFile(filename)
        if err != nil || parsedFile == nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov6" title="6">content, _, _ := parsedFile.Body.PartialContent(&amp;hcl.BodySchema{
                Blocks: []hcl.BlockHeaderSchema{
                        {
                                Type:       "variable",
                                LabelNames: []string{"name"},
                        },
                },
        })
        defaultValuesMap := make(converter.InputVariableMap)
        for _, block := range content.Blocks </span><span class="cov7" title="8">{
                if len(block.Labels) == 0 || block.Labels[0] == "" </span><span class="cov3" title="2">{
                        continue</span>
                }
                <span class="cov6" title="6">attr, _ := block.Body.JustAttributes()
                if attr == nil || len(attr) == 0 </span><span class="cov3" title="2">{
                        continue</span>
                }
                <span class="cov5" title="4">if defaultValue, exists := attr["default"]; exists </span><span class="cov5" title="4">{
                        defaultVar, _ := defaultValue.Expr.Value(nil)
                        defaultValuesMap[block.Labels[0]] = defaultVar
                }</span>
        }
        <span class="cov6" title="6">return defaultValuesMap, nil</span>
}

func checkTfvarsValid(f *hcl.File, filename string) error <span class="cov6" title="5">{
        content, _, _ := f.Body.PartialContent(&amp;hcl.BodySchema{
                Blocks: []hcl.BlockHeaderSchema{
                        {
                                Type:       "variable",
                                LabelNames: []string{"name"},
                        },
                },
        })
        if len(content.Blocks) &gt; 0 </span><span class="cov3" title="2">{
                return fmt.Errorf("failed to get variables from %s, .tfvars file is used to assing values not to declare new variables", filename)
        }</span>
        <span class="cov4" title="3">return nil</span>
}

func getInputVariablesFromFile(filename string) (converter.InputVariableMap, error) <span class="cov6" title="6">{
        parsedFile, err := parseFile(filename)
        if err != nil || parsedFile == nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov6" title="5">err = checkTfvarsValid(parsedFile, filename)
        if err != nil </span><span class="cov3" title="2">{
                return nil, err
        }</span>

        <span class="cov4" title="3">attrs := parsedFile.Body.(*hclsyntax.Body).Attributes
        variables := make(converter.InputVariableMap)
        for name, attr := range attrs </span><span class="cov8" title="9">{
                value, _ := attr.Expr.Value(&amp;hcl.EvalContext{})
                variables[name] = value
        }</span>
        <span class="cov4" title="3">return variables, nil</span>
}

func getInputVariables(currentPath string) <span class="cov3" title="2">{
        variablesMap := make(converter.InputVariableMap)
        tfFiles, err := filepath.Glob(filepath.Join(currentPath, "*.tf"))
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msg("Error getting .tf files")
        }</span>
        <span class="cov3" title="2">for _, tfFile := range tfFiles </span><span class="cov4" title="3">{
                variables, errDefaultValues := setInputVariablesDefaultValues(tfFile)
                if errDefaultValues != nil </span><span class="cov0" title="0">{
                        log.Error().Msgf("Error getting default values from %s", tfFile)
                        log.Err(errDefaultValues)
                        continue</span>
                }
                <span class="cov4" title="3">mergeMaps(variablesMap, variables)</span>
        }
        <span class="cov3" title="2">tfVarsFiles, err := filepath.Glob(filepath.Join(currentPath, "*.auto.tfvars"))
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msg("Error getting .auto.tfvars files")
        }</span>

        <span class="cov3" title="2">_, err = os.Stat(filepath.Join(currentPath, "terraform.tfvars"))
        if err != nil </span><span class="cov1" title="1">{
                log.Info().Msg("terraform.tfvars not found")
        }</span> else<span class="cov1" title="1"> {
                tfVarsFiles = append(tfVarsFiles, filepath.Join(currentPath, "terraform.tfvars"))
        }</span>

        <span class="cov3" title="2">for _, tfVarsFile := range tfVarsFiles </span><span class="cov4" title="3">{
                variables, errInputVariables := getInputVariablesFromFile(tfVarsFile)
                if errInputVariables != nil </span><span class="cov1" title="1">{
                        log.Error().Msgf("Error getting values from %s", tfVarsFiles)
                        log.Err(errInputVariables)
                        continue</span>
                }
                <span class="cov3" title="2">mergeMaps(variablesMap, variables)</span>
        }
        <span class="cov3" title="2">inputVariableMap["var"] = cty.ObjectVal(variablesMap)</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package json

import (
        "bytes"
        "encoding/json"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/pkg/errors"
        "gopkg.in/yaml.v3"
)

// Parser defines a parser type
type Parser struct {
}

// Playbooks represents a playbook object from parsed yaml files
type Playbooks struct {
        Tasks []map[string]interface{} `json:"playbooks"`
}

// Resolve - replace or modifies in-memory content before parsing
func (p *Parser) Resolve(fileContent []byte, filename string) (*[]byte, error) <span class="cov1" title="1">{
        return &amp;fileContent, nil
}</span>

// Parse parses yaml/yml file and returns it as a Document
func (p *Parser) Parse(_ string, fileContent []byte) ([]model.Document, error) <span class="cov10" title="2">{
        var documents []model.Document
        dec := yaml.NewDecoder(bytes.NewReader(fileContent))

        doc := &amp;model.Document{}
        for dec.Decode(doc) == nil </span><span class="cov10" title="2">{
                if doc != nil </span><span class="cov10" title="2">{
                        documents = append(documents, *doc)
                }</span>
                <span class="cov10" title="2">doc = &amp;model.Document{}</span>
        }

        <span class="cov10" title="2">if documents == nil </span><span class="cov1" title="1">{
                var err error
                documents, err = playbookParser(fileContent)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to Parse YAML")
                }</span>
                <span class="cov1" title="1">if documents == nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(errors.New("invalid yaml"), "failed to parse yaml")
                }</span>
        }

        <span class="cov10" title="2">return documents, nil</span>
}

// SupportedExtensions returns extensions supported by this parser, which are yaml and yml extension
func (p *Parser) SupportedExtensions() []string <span class="cov1" title="1">{
        return []string{".yaml", ".yml"}
}</span>

// SupportedTypes returns types supported by this parser, which are ansible, cloudFormation, k8s
func (p *Parser) SupportedTypes() []string <span class="cov1" title="1">{
        return []string{"Ansible", "CloudFormation", "Kubernetes", "OpenAPI"}
}</span>

// GetKind returns YAML constant kind
func (p *Parser) GetKind() model.FileKind <span class="cov1" title="1">{
        return model.KindYAML
}</span>

func playbookParser(fileContent []byte) ([]model.Document, error) <span class="cov1" title="1">{
        doc := &amp;model.Document{}
        dec := yaml.NewDecoder(bytes.NewReader(fileContent))
        arr := make([]map[string]interface{}, 0)
        var playBooks Playbooks
        var documents []model.Document
        for dec.Decode(&amp;arr) == nil </span><span class="cov1" title="1">{
                if doc != nil </span><span class="cov1" title="1">{
                        playBooks.Tasks = append(playBooks.Tasks, arr...)
                        j, err := json.Marshal(playBooks)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errors.Wrap(err, "failed to Marshal YAML")
                        }</span>

                        <span class="cov1" title="1">if err := json.Unmarshal(j, &amp;doc); err != nil </span><span class="cov0" title="0">{
                                return nil, errors.Wrap(err, "failed to Unmarshal YAML")
                        }</span>
                        <span class="cov1" title="1">documents = append(documents, *doc)</span>
                }
                <span class="cov1" title="1">doc = &amp;model.Document{}
                arr = make([]map[string]interface{}, 0)</span>
        }

        <span class="cov1" title="1">return documents, nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package report

import (
        "fmt"
        "html/template"
        "os"
        "strings"
        "time"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/rs/zerolog/log"
)

var templateFuncs = template.FuncMap{
        "lower":          strings.ToLower,
        "sprintf":        fmt.Sprintf,
        "severity":       getSeverities,
        "getCurrentTime": getCurrentTime,
        "trimSpaces":     trimSpaces,
}

var stringsSeverity = map[string]model.Severity{
        "high":   model.AllSeverities[0],
        "medium": model.AllSeverities[1],
        "low":    model.AllSeverities[2],
        "info":   model.AllSeverities[3],
}

func trimSpaces(value string) string <span class="cov0" title="0">{
        return strings.TrimPrefix(value, " ")
}</span>

func getSeverities(severity string) model.Severity <span class="cov10" title="4">{
        return stringsSeverity[severity]
}</span>

func getCurrentTime() string <span class="cov1" title="1">{
        dt := time.Now()
        return fmt.Sprint(dt.Format("01/02/2006 15:04"))
}</span>

func closeFile(path, filename string, file *os.File) <span class="cov8" title="3">{
        err := file.Close()
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err).Msgf("Failed to close file %s", path)
        }</span>

        <span class="cov8" title="3">log.Info().Str("fileName", filename).Msgf("Results saved to file %s", path)</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package report

import (
        "bytes"
        _ "embed" // used for embedding report static files
        "html/template"
        "os"
        "path/filepath"
        "strings"

        "github.com/tdewolff/minify/v2"
        minifyCSS "github.com/tdewolff/minify/v2/css"
        minifyHtml "github.com/tdewolff/minify/v2/html"
        minifyJS "github.com/tdewolff/minify/v2/js"
)

var (
        //go:embed template/html/report.tmpl
        htmlTemplate string
        //go:embed template/html/report.css
        cssTemplate string
        //go:embed template/html/report.js
        jsTemplate string
        //go:embed template/html/github.svg
        githubSVG string
        //go:embed template/html/info.svg
        infoSVG string
        //go:embed template/html/vulnerability_fill.svg
        vulnerabilityFillSVG string
        //go:embed template/html/vulnerability_out.svg
        vulnerabilityOutSVG string
)

var svgMap = map[string]string{
        "github.svg":             githubSVG,
        "info.svg":               infoSVG,
        "vulnerability_fill.svg": vulnerabilityFillSVG,
        "vulnerability_out.svg":  vulnerabilityOutSVG,
}

func includeSVG(name string) template.HTML <span class="cov10" title="7">{
        return template.HTML(svgMap[name]) //nolint
}</span>

func includeCSS(name string) template.HTML <span class="cov1" title="1">{
        minifier := minify.New()
        minifier.AddFunc("text/css", minifyCSS.Minify)
        cssMinified, err := minifier.String("text/css", cssTemplate)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov1" title="1">return template.HTML("&lt;style&gt;" + cssMinified + "&lt;/style&gt;")</span> //nolint
}

func includeJS(name string) template.HTML <span class="cov1" title="1">{
        minifier := minify.New()
        minifier.AddFunc("text/javascript", minifyJS.Minify)
        jsMinified, err := minifier.String("text/javascript", jsTemplate)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov1" title="1">return template.HTML("&lt;script&gt;" + jsMinified + "&lt;/script&gt;")</span> //nolint
}

// PrintHTMLReport creates a report file on HTML format
func PrintHTMLReport(path, filename string, body interface{}) error <span class="cov1" title="1">{
        if !strings.HasSuffix(filename, ".html") </span><span class="cov1" title="1">{
                filename += ".html"
        }</span>

        <span class="cov1" title="1">templateFuncs["includeSVG"] = includeSVG
        templateFuncs["includeCSS"] = includeCSS
        templateFuncs["includeJS"] = includeJS

        fullPath := filepath.Join(path, filename)
        t := template.Must(template.New("report.tmpl").Funcs(templateFuncs).Parse(htmlTemplate))

        _ = os.MkdirAll(path, os.ModePerm)
        f, err := os.OpenFile(filepath.Clean(fullPath), os.O_WRONLY|os.O_CREATE|os.O_TRUNC, os.ModePerm)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">defer closeFile(fullPath, filename, f)
        var buffer bytes.Buffer

        err = t.Execute(&amp;buffer, body)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">minifier := minify.New()
        minifier.AddFunc("text/html", minifyHtml.Minify)
        minifier.Add("text/html", &amp;minifyHtml.Minifier{
                KeepDocumentTags: true,
                KeepEndTags:      true,
                KeepQuotes:       true,
        })

        minifierWriter := minifier.Writer("text/html", f)
        defer minifierWriter.Close()

        _, err = minifierWriter.Write(buffer.Bytes())
        return err</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package report

import (
        "encoding/json"
        "os"
        "path/filepath"
        "strings"
)

// PrintJSONReport prints on JSON file the summary results
func PrintJSONReport(path, filename string, body interface{}) error <span class="cov10" title="2">{
        if !strings.Contains(filename, ".") </span><span class="cov1" title="1">{
                filename += ".json"
        }</span>
        <span class="cov10" title="2">fullPath := filepath.Join(path, filename)
        _ = os.MkdirAll(path, os.ModePerm)

        f, err := os.OpenFile(filepath.Clean(fullPath), os.O_WRONLY|os.O_CREATE|os.O_TRUNC, os.ModePerm)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="2">defer closeFile(fullPath, filename, f)

        encoder := json.NewEncoder(f)
        encoder.SetIndent("", "\t")

        return encoder.Encode(body)</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package report

import (
        "encoding/json"
        "strings"

        "github.com/Checkmarx/kics/pkg/model"
)

// PrintSarifReport creates a report file on sarif format
func PrintSarifReport(path, filename string, body interface{}) error <span class="cov8" title="1">{
        if !strings.HasSuffix(filename, ".sarif") </span><span class="cov8" title="1">{
                filename += ".sarif"
        }</span>
        <span class="cov8" title="1">var summary model.Summary
        result, err := json.Marshal(body)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := json.Unmarshal(result, &amp;summary); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">sarifReport := model.NewSarifReport()
        for idx := range summary.Queries </span><span class="cov8" title="1">{
                sarifReport.BuildIssue(&amp;summary.Queries[idx])
        }</span>

        <span class="cov8" title="1">return PrintJSONReport(path, filename, sarifReport)</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package helm

import (
        "fmt"
        "io"
        "log"
        "os"
        "strings"

        "github.com/pkg/errors"
        "helm.sh/helm/v3/pkg/action"
        "helm.sh/helm/v3/pkg/chart"
        "helm.sh/helm/v3/pkg/chart/loader"
        "helm.sh/helm/v3/pkg/chartutil"
        "helm.sh/helm/v3/pkg/cli"
        "helm.sh/helm/v3/pkg/cli/values"
        "helm.sh/helm/v3/pkg/getter"
        "helm.sh/helm/v3/pkg/release"
)

// credit: https://github.com/helm/helm

var (
        settings = cli.New()
)

func runInstall(args []string, client *action.Install,
        valueOpts *values.Options) (*release.Release, error) <span class="cov2" title="3">{
        log.SetOutput(io.Discard)
        defer log.SetOutput(os.Stderr)
        if client.Version == "" &amp;&amp; client.Devel </span><span class="cov0" title="0">{
                client.Version = "&gt;0.0.0-0"
        }</span>

        <span class="cov2" title="3">name, charts, err := client.NameAndChart(args)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov2" title="3">client.ReleaseName = name

        cp, err := client.ChartPathOptions.LocateChart(charts, settings)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="3">p := getter.All(settings)
        vals, err := valueOpts.MergeValues(p)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Check chart dependencies to make sure all are present in /charts
        <span class="cov2" title="3">chartRequested, err := loader.Load(cp)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov2" title="2">chartRequested = setID(chartRequested)

        if err := checkIfInstallable(chartRequested); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="2">client.Namespace = "kics-namespace"
        return client.Run(chartRequested, vals)</span>
}

// checkIfInstallable validates if a chart can be installed
//
// Application chart type is only installable
func checkIfInstallable(ch *chart.Chart) error <span class="cov2" title="2">{
        switch ch.Metadata.Type </span>{
        case "", "application":<span class="cov2" title="2">
                return nil</span>
        }
        <span class="cov0" title="0">return errors.Errorf("%s charts are not installable", ch.Metadata.Type)</span>
}

// newClient will create a new instance on helm client used to render the chart
func newClient() *action.Install <span class="cov2" title="3">{
        cfg := new(action.Configuration)
        client := action.NewInstall(cfg)
        client.DryRun = true
        client.ReleaseName = "kics-helm"
        client.Replace = true // Skip the name check
        client.ClientOnly = true
        client.APIVersions = chartutil.VersionSet([]string{})
        client.IncludeCRDs = false
        return client
}</span>

// setID will add auxiliary lines for each template as well as its dependencies
func setID(chartReq *chart.Chart) *chart.Chart <span class="cov2" title="3">{
        for _, temp := range chartReq.Templates </span><span class="cov4" title="9">{
                temp = addID(temp) //nolint
                if temp != nil </span><span class="cov4" title="9">{
                        continue</span>
                }
        }
        <span class="cov2" title="3">for _, dep := range chartReq.Dependencies() </span><span class="cov1" title="1">{
                dep = setID(dep) //nolint
                if dep != nil </span><span class="cov1" title="1">{
                        continue</span>
                }
        }
        <span class="cov2" title="3">return chartReq</span>
}

// addID will add auxiliary lines used to detect line
// one for each "apiVersion:" where the id will be the line
func addID(file *chart.File) *chart.File <span class="cov4" title="9">{
        split := strings.Split(string(file.Data), "\n")
        for i := 0; i &lt; len(split); i++ </span><span class="cov10" title="303">{
                if strings.Contains(split[i], "apiVersion:") </span><span class="cov2" title="3">{
                        split = append(split, "")
                        copy(split[i+1:], split[i:])
                        split[i] = fmt.Sprintf("# KICS_HELM_ID_%d:", i)
                        i++
                }</span>
        }
        <span class="cov4" title="9">file.Data = []byte(strings.Join(split, "\n"))
        return file</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package helm

import (
        "path/filepath"
        "strconv"
        "strings"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/pkg/errors"
        "helm.sh/helm/v3/pkg/chart"
        "helm.sh/helm/v3/pkg/cli/values"
        "helm.sh/helm/v3/pkg/release"
)

// Resolver is an instance of the helm resolver
type Resolver struct {
}

// splitManifest keeps the information of the manifest splitted by source
type splitManifest struct {
        path       string
        content    []byte
        original   []byte
        splitID    string
        splitIDMap map[int]interface{}
}

// Resolve will render the passed helm chart and return its content ready for parsing
func (r *Resolver) Resolve(filePath string) (model.ResolvedFiles, error) <span class="cov3" title="3">{
        var rfiles = model.ResolvedFiles{}
        splits, err := renderHelm(filePath)
        if err != nil </span><span class="cov1" title="1">{ // return error to be logged
                return model.ResolvedFiles{}, errors.New("failed to render helm chart")
        }</span>
        <span class="cov2" title="2">for _, split := range *splits </span><span class="cov3" title="3">{
                origpath := filepath.Join(filepath.Dir(filePath), split.path)
                rfiles.File = append(rfiles.File, model.ResolvedFile{
                        FileName:     origpath,
                        Content:      split.content,
                        OriginalData: split.original,
                        SplitID:      split.splitID,
                        IDInfo:       split.splitIDMap,
                })
        }</span>
        <span class="cov2" title="2">return rfiles, nil</span>
}

// SupportedTypes returns the supported fileKinds for this resolver
func (r *Resolver) SupportedTypes() []model.FileKind <span class="cov1" title="1">{
        return []model.FileKind{model.KindHELM}
}</span>

// renderHelm will use helm library to render helm charts
func renderHelm(path string) (*[]splitManifest, error) <span class="cov3" title="3">{
        client := newClient()
        manifest, err := runInstall([]string{path}, client, &amp;values.Options{})
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov2" title="2">return splitManifestYAML(manifest)</span>
}

// splitManifestYAML will split the rendered file and return its content by template as well as the template path
func splitManifestYAML(template *release.Release) (*[]splitManifest, error) <span class="cov2" title="2">{
        sources := make([]*chart.File, 0)
        sources = updateName(sources, template.Chart, template.Chart.Name())
        splitedManifest := []splitManifest{}
        splitedSource := strings.Split(template.Manifest, "---") // split manifest by '---'
        origData := toMap(sources)
        for _, splited := range splitedSource </span><span class="cov4" title="5">{
                var lineID string
                for _, line := range strings.Split(splited, "\n") </span><span class="cov6" title="11">{
                        if strings.Contains(line, "# KICS_HELM_ID_") </span><span class="cov3" title="3">{
                                lineID = line // get auxiliary line id
                                break</span>
                        }
                }
                <span class="cov4" title="5">path := strings.Split(strings.TrimLeft(splited, "\n# Source:"), "\n") // get source of splitted yaml
                // ignore auxiliary files used to render chart
                if path[0] == "" </span><span class="cov2" title="2">{
                        continue</span>
                }
                <span class="cov3" title="3">if origData[filepath.FromSlash(path[0])] == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov3" title="3">idMap, err := getIDMap(origData[filepath.FromSlash(path[0])])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov3" title="3">splitedManifest = append(splitedManifest, splitManifest{
                        path:       path[0],
                        content:    []byte(strings.ReplaceAll(splited, "\r", "")),
                        original:   origData[filepath.FromSlash(path[0])], // get original data from template
                        splitID:    lineID,
                        splitIDMap: idMap,
                })</span>
        }
        <span class="cov2" title="2">return &amp;splitedManifest, nil</span>
}

// toMap will convert to map original data having the path as it's key
func toMap(files []*chart.File) map[string][]byte <span class="cov2" title="2">{
        mapFiles := make(map[string][]byte)
        for _, file := range files </span><span class="cov6" title="9">{
                mapFiles[file.Name] = []byte(strings.ReplaceAll(string(file.Data), "\r", ""))
        }</span>
        <span class="cov2" title="2">return mapFiles</span>
}

// updateName will update the templates name as well as its dependecies
func updateName(template []*chart.File, charts *chart.Chart, name string) []*chart.File <span class="cov3" title="3">{
        if name != charts.Name() </span><span class="cov1" title="1">{
                name = filepath.Join(name, charts.Name())
        }</span>
        <span class="cov3" title="3">for _, temp := range charts.Templates </span><span class="cov6" title="9">{
                temp.Name = filepath.Join(name, temp.Name)
        }</span>
        <span class="cov3" title="3">template = append(template, charts.Templates...)
        for _, dep := range charts.Dependencies() </span><span class="cov1" title="1">{
                template = updateName(template, dep, filepath.Join(name, "charts"))
        }</span>
        <span class="cov3" title="3">return template</span>
}

// getIdMap will construct a map with ids with the corresponding lines as keys
// for use in detector
func getIDMap(originalData []byte) (map[int]interface{}, error) <span class="cov3" title="3">{
        ids := make(map[int]interface{})
        mapLines := make(map[int]int)
        idHelm := -1
        for line, stringLine := range strings.Split(string(originalData), "\n") </span><span class="cov10" title="48">{
                if strings.Contains(stringLine, "# KICS_HELM_ID_") </span><span class="cov3" title="3">{
                        id, err := strconv.Atoi(strings.TrimSuffix(strings.TrimPrefix(stringLine, "# KICS_HELM_ID_"), ":"))
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov3" title="3">if idHelm == -1 </span><span class="cov3" title="3">{
                                idHelm = id
                                mapLines[line] = line
                        }</span> else<span class="cov0" title="0"> {
                                ids[idHelm] = mapLines
                                mapLines = make(map[int]int)
                                idHelm = id
                                mapLines[line] = line
                        }</span>
                } else<span class="cov9" title="45"> if idHelm != -1 </span><span class="cov9" title="44">{
                        mapLines[line] = line
                }</span>
        }
        <span class="cov3" title="3">ids[idHelm] = mapLines

        return ids, nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package resolver

import (
        "os"
        "path/filepath"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/rs/zerolog/log"
)

// kindResolver is a type of resolver interface (ex: helm resolver)
// Resolve will render file/template
// SupportedTypes will return the file kinds that the resolver supports
type kindResolver interface {
        Resolve(filePath string) (model.ResolvedFiles, error)
        SupportedTypes() []model.FileKind
}

// Resolver is a struct containing the resolvers by file kind
type Resolver struct {
        resolvers map[model.FileKind]kindResolver
}

// Builder is a struct used to create a new resolver
type Builder struct {
        resolvers []kindResolver
}

// NewBuilder creates a new Builder's reference
func NewBuilder() *Builder <span class="cov10" title="2">{
        return &amp;Builder{}
}</span>

// Add will add kindResolvers for building the resolver
func (b *Builder) Add(p kindResolver) *Builder <span class="cov10" title="2">{
        log.Debug().Msgf("resolver.Add()")
        b.resolvers = append(b.resolvers, p)
        return b
}</span>

// Build will create a new intance of a resolver
func (b *Builder) Build() (*Resolver, error) <span class="cov10" title="2">{
        log.Debug().Msg("resolver.Build()")

        resolvers := make(map[model.FileKind]kindResolver, len(b.resolvers))
        for _, resolver := range b.resolvers </span><span class="cov10" title="2">{
                for _, typeRes := range resolver.SupportedTypes() </span><span class="cov10" title="2">{
                        resolvers[typeRes] = resolver
                }</span>
        }

        <span class="cov10" title="2">return &amp;Resolver{
                resolvers: resolvers,
        }, nil</span>
}

// Resolve will resolve the files according to its type
func (r *Resolver) Resolve(filePath string, kind model.FileKind) (model.ResolvedFiles, error) <span class="cov1" title="1">{
        if r, ok := r.resolvers[kind]; ok </span><span class="cov1" title="1">{
                obj, err := r.Resolve(filePath)
                if err != nil </span><span class="cov0" title="0">{
                        return model.ResolvedFiles{}, nil
                }</span>
                <span class="cov1" title="1">log.Debug().Msgf("resolver.Resolve() rendered file: %s", filePath)
                return obj, nil</span>
        }
        // need to log here
        <span class="cov0" title="0">return model.ResolvedFiles{}, nil</span>
}

// GetType will analyze the filepath to determine which resolver to use
func (r *Resolver) GetType(filePath string) model.FileKind <span class="cov10" title="2">{
        _, err := os.Stat(filepath.Join(filePath, "Chart.yaml"))
        if err == nil </span><span class="cov1" title="1">{
                return model.KindHELM
        }</span>
        <span class="cov1" title="1">return model.KindCOMMON</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package test

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "strings"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/spf13/cobra"
)

// ValidUUIDRegex is a constant representing a regular expression rule to validate UUID string
const ValidUUIDRegex = `(?i)^[0-9a-f]{8}-[0-9a-f]{4}-[0-5][0-9a-f]{3}-[089ab][0-9a-f]{3}-[0-9a-f]{12}$`

type execute func() error

// CaptureOutput changes default stdout to intercept into a buffer, converts it to string and returns it
func CaptureOutput(funcToExec execute) (string, error) <span class="cov0" title="0">{
        old := os.Stdout
        r, w, _ := os.Pipe()
        os.Stdout = w

        err := funcToExec()

        outC := make(chan string)

        go func() </span><span class="cov0" title="0">{
                var buf bytes.Buffer
                if _, errors := io.Copy(&amp;buf, r); errors != nil </span><span class="cov0" title="0">{ // nolint
                        return
                }</span>
                <span class="cov0" title="0">outC &lt;- buf.String()</span>
        }()

        <span class="cov0" title="0">if errors := w.Close(); errors != nil </span><span class="cov0" title="0">{
                return "", errors
        }</span>
        <span class="cov0" title="0">os.Stdout = old
        out := &lt;-outC

        return out, err</span>
}

// CaptureCommandOutput set cobra command args, if necessary, then capture the output
func CaptureCommandOutput(cmd *cobra.Command, args []string) (string, error) <span class="cov0" title="0">{
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                cmd.SetArgs(args)
        }</span>

        <span class="cov0" title="0">return CaptureOutput(cmd.Execute)</span>
}

// ChangeCurrentDir gets current working directory and changes to its parent until finds the desired directory
// or fail
func ChangeCurrentDir(desiredDir string) error <span class="cov0" title="0">{
        for currentDir, err := os.Getwd(); GetCurrentDirName(currentDir) != desiredDir; currentDir, err = os.Getwd() </span><span class="cov0" title="0">{
                if err == nil </span><span class="cov0" title="0">{
                        if err = os.Chdir(".."); err != nil </span><span class="cov0" title="0">{
                                fmt.Print(formatCurrentDirError(err))
                                return fmt.Errorf(formatCurrentDirError(err))
                        }</span>
                } else<span class="cov0" title="0"> {
                        return fmt.Errorf(formatCurrentDirError(err))
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func formatCurrentDirError(err error) string <span class="cov0" title="0">{
        return fmt.Sprintf("change path error = %v", err)
}</span>

// GetCurrentDirName returns current working directory
func GetCurrentDirName(path string) string <span class="cov0" title="0">{
        dirs := strings.Split(path, string(os.PathSeparator))
        if dirs[len(dirs)-1] == "" &amp;&amp; len(dirs) &gt; 1 </span><span class="cov0" title="0">{
                return dirs[len(dirs)-2]
        }</span>
        <span class="cov0" title="0">return dirs[len(dirs)-1]</span>
}

// StringifyStruct stringify struct for pretty print
func StringifyStruct(v interface{}) (string, error) <span class="cov0" title="0">{
        jsonValue, err := json.MarshalIndent(v, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return string(jsonValue), nil</span>
}

// MapToStringSlice extract slice of keys from a map[string]string
func MapToStringSlice(stringKeyMap map[string]string) []string <span class="cov3" title="2">{
        keys := make([]string, len(stringKeyMap))

        i := 0
        for k := range stringKeyMap </span><span class="cov10" title="21">{
                keys[i] = k
                i++
        }</span>
        <span class="cov3" title="2">return keys</span>
}

var queryHigh = model.VulnerableQuery{
        QueryName: "ALB protocol is HTTP",
        QueryID:   "de7f5e83-da88-4046-871f-ea18504b1d43",
        Severity:  model.SeverityHigh,
        Files: []model.VulnerableFile{
                {
                        FileName:         "positive.tf",
                        Line:             25,
                        IssueType:        "MissingAttribute",
                        SearchKey:        "aws_alb_listener[front_end].default_action.redirect",
                        KeyExpectedValue: "'default_action.redirect.protocol' is equal 'HTTPS'",
                        KeyActualValue:   "'default_action.redirect.protocol' is missing",
                        Value:            nil,
                },
                {
                        FileName:         "positive.tf",
                        Line:             19,
                        IssueType:        "IncorrectValue",
                        SearchKey:        "aws_alb_listener[front_end].default_action.redirect",
                        KeyExpectedValue: "'default_action.redirect.protocol' is equal 'HTTPS'",
                        KeyActualValue:   "'default_action.redirect.protocol' is equal 'HTTP'",
                        Value:            nil,
                },
        },
}

var queryMedium = model.VulnerableQuery{
        QueryName: "AmazonMQ Broker Encryption Disabled",
        QueryID:   "3db3f534-e3a3-487f-88c7-0a9fbf64b702",
        Severity:  model.SeverityMedium,
        Files: []model.VulnerableFile{
                {
                        FileName:         "positive.tf",
                        Line:             1,
                        IssueType:        "MissingAttribute",
                        SearchKey:        "resource.aws_mq_broker[positive1]",
                        KeyExpectedValue: "resource.aws_mq_broker[positive1].encryption_options is defined",
                        KeyActualValue:   "resource.aws_mq_broker[positive1].encryption_options is not defined",
                        Value:            nil,
                },
        },
}

// SummaryMock a summary to be used without running kics scan
var SummaryMock = model.Summary{
        Counters: model.Counters{
                ScannedFiles:           1,
                ParsedFiles:            1,
                FailedToScanFiles:      0,
                TotalQueries:           1,
                FailedToExecuteQueries: 0,
        },
        Queries: []model.VulnerableQuery{
                queryHigh,
        },
        SeveritySummary: model.SeveritySummary{
                ScanID: "console",
                SeverityCounters: map[model.Severity]int{
                        model.SeverityInfo:   0,
                        model.SeverityLow:    0,
                        model.SeverityMedium: 0,
                        model.SeverityHigh:   2,
                },
                TotalCounter: 2,
        },
}

// ComplexSummaryMock a summary with more results to be used without running kics scan
var ComplexSummaryMock = model.Summary{
        Counters: model.Counters{
                ScannedFiles:           2,
                ParsedFiles:            2,
                FailedToScanFiles:      0,
                TotalQueries:           2,
                FailedToExecuteQueries: 0,
        },
        Queries: []model.VulnerableQuery{
                queryHigh,
                queryMedium,
        },
        SeveritySummary: model.SeveritySummary{
                ScanID: "console",
                SeverityCounters: map[model.Severity]int{
                        model.SeverityInfo:   0,
                        model.SeverityLow:    0,
                        model.SeverityMedium: 1,
                        model.SeverityHigh:   2,
                },
                TotalCounter: 3,
        },
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
